#include "import.h"

#include <GL/glew.h>
#include <SDL2/SDL_video.h>
#include <unicorn/unicorn.h>

#include <array>
#include <fstream>
#include <iostream>
#include <sstream>

enum GxmMemoryAttrib
{
    // https://github.com/xerpi/vitahelloworld/blob/master/draw.c
    SCE_GXM_MEMORY_ATTRIB_READ = 1,
    SCE_GXM_MEMORY_ATTRIB_RW = 3
};

enum SceGxmAttributeFormat : uint8_t
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_ATTRIBUTE_FORMAT_U8,
    SCE_GXM_ATTRIBUTE_FORMAT_S8,
    SCE_GXM_ATTRIBUTE_FORMAT_U16,
    SCE_GXM_ATTRIBUTE_FORMAT_S16,
    SCE_GXM_ATTRIBUTE_FORMAT_U8N,
    SCE_GXM_ATTRIBUTE_FORMAT_S8N,
    SCE_GXM_ATTRIBUTE_FORMAT_U16N,
    SCE_GXM_ATTRIBUTE_FORMAT_S16N,
    SCE_GXM_ATTRIBUTE_FORMAT_F16,
    SCE_GXM_ATTRIBUTE_FORMAT_F32
};

enum SceGxmColorMask
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_COLOR_MASK_NONE = 0,
    SCE_GXM_COLOR_MASK_A = (1 << 0),
    SCE_GXM_COLOR_MASK_R = (1 << 1),
    SCE_GXM_COLOR_MASK_G = (1 << 2),
    SCE_GXM_COLOR_MASK_B = (1 << 3),
    SCE_GXM_COLOR_MASK_ALL = (SCE_GXM_COLOR_MASK_A | SCE_GXM_COLOR_MASK_R | SCE_GXM_COLOR_MASK_G | SCE_GXM_COLOR_MASK_B)
};

enum SceGxmBlendFactor
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_BLEND_FACTOR_ZERO,
    SCE_GXM_BLEND_FACTOR_ONE,
    SCE_GXM_BLEND_FACTOR_SRC_COLOR,
    SCE_GXM_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
    SCE_GXM_BLEND_FACTOR_SRC_ALPHA,
    SCE_GXM_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
    SCE_GXM_BLEND_FACTOR_DST_COLOR,
    SCE_GXM_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
    SCE_GXM_BLEND_FACTOR_DST_ALPHA,
    SCE_GXM_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
    SCE_GXM_BLEND_FACTOR_SRC_ALPHA_SATURATE,
    SCE_GXM_BLEND_FACTOR_DST_ALPHA_SATURATE
};

enum SceGxmBlendFunc
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_BLEND_FUNC_NONE,
    SCE_GXM_BLEND_FUNC_ADD,
    SCE_GXM_BLEND_FUNC_SUBTRACT,
    SCE_GXM_BLEND_FUNC_REVERSE_SUBTRACT
};

struct SceGxmBlendInfo
{
    // https://psp2sdk.github.io/structSceGxmBlendInfo.html
    // TODO I don't think this is right.
    SceGxmColorMask colorMask;
    SceGxmBlendFunc colorFunc : 4;
    SceGxmBlendFunc alphaFunc : 4;
    SceGxmBlendFactor colorSrc : 4;
    SceGxmBlendFactor colorDst : 4;
    SceGxmBlendFactor alphaSrc : 4;
    SceGxmBlendFactor alphaDst : 4;
};

enum SceGxmColorBaseFormat
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_COLOR_BASE_FORMAT_U8U8U8U8 = 0x00000000,
    SCE_GXM_COLOR_BASE_FORMAT_U8U8U8 = 0x10000000,
    SCE_GXM_COLOR_BASE_FORMAT_U5U6U5 = 0x30000000,
    SCE_GXM_COLOR_BASE_FORMAT_U1U5U5U5 = 0x40000000,
    SCE_GXM_COLOR_BASE_FORMAT_U4U4U4U4 = 0x50000000,
    SCE_GXM_COLOR_BASE_FORMAT_U8U3U3U2 = 0x60000000,
    SCE_GXM_COLOR_BASE_FORMAT_F16 = 0xf0000000,
    SCE_GXM_COLOR_BASE_FORMAT_F16F16 = 0x00800000,
    SCE_GXM_COLOR_BASE_FORMAT_F32 = 0x10800000,
    SCE_GXM_COLOR_BASE_FORMAT_S16 = 0x20800000,
    SCE_GXM_COLOR_BASE_FORMAT_S16S16 = 0x30800000,
    SCE_GXM_COLOR_BASE_FORMAT_U16 = 0x40800000,
    SCE_GXM_COLOR_BASE_FORMAT_U16U16 = 0x50800000,
    SCE_GXM_COLOR_BASE_FORMAT_U2U10U10U10 = 0x60800000,
    SCE_GXM_COLOR_BASE_FORMAT_U8 = 0x80800000,
    SCE_GXM_COLOR_BASE_FORMAT_S8 = 0x90800000,
    SCE_GXM_COLOR_BASE_FORMAT_S5S5U6 = 0xa0800000,
    SCE_GXM_COLOR_BASE_FORMAT_U8U8 = 0xb0800000,
    SCE_GXM_COLOR_BASE_FORMAT_S8S8 = 0xc0800000,
    SCE_GXM_COLOR_BASE_FORMAT_U8S8S8U8 = 0xd0800000,
    SCE_GXM_COLOR_BASE_FORMAT_S8S8S8S8 = 0xe0800000,
    SCE_GXM_COLOR_BASE_FORMAT_F16F16F16F16 = 0x01000000,
    SCE_GXM_COLOR_BASE_FORMAT_F32F32 = 0x11000000,
    SCE_GXM_COLOR_BASE_FORMAT_F11F11F10 = 0x21000000,
    SCE_GXM_COLOR_BASE_FORMAT_SE5M9M9M9 = 0x31000000,
    SCE_GXM_COLOR_BASE_FORMAT_U2F10F10F10 = 0x41000000
};

enum SceGxmColorSwizzle1Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_COLOR_SWIZZLE1_R = 0x00000000,
    SCE_GXM_COLOR_SWIZZLE1_G = 0x00100000,
    SCE_GXM_COLOR_SWIZZLE1_A = 0x00100000
};

enum SceGxmColorSwizzle2Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_COLOR_SWIZZLE2_GR = 0x00000000,
    SCE_GXM_COLOR_SWIZZLE2_RG = 0x00100000,
    SCE_GXM_COLOR_SWIZZLE2_RA = 0x00200000,
    SCE_GXM_COLOR_SWIZZLE2_AR = 0x00300000
};

enum SceGxmColorSwizzle3Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_COLOR_SWIZZLE3_BGR = 0x00000000,
    SCE_GXM_COLOR_SWIZZLE3_RGB = 0x00100000
};

enum SceGxmColorSwizzle4Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_COLOR_SWIZZLE4_ABGR = 0x00000000,
    SCE_GXM_COLOR_SWIZZLE4_ARGB = 0x00100000,
    SCE_GXM_COLOR_SWIZZLE4_RGBA = 0x00200000,
    SCE_GXM_COLOR_SWIZZLE4_BGRA = 0x00300000
};

enum SceGxmColorFormat
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_COLOR_FORMAT_U8U8U8U8_ABGR = SCE_GXM_COLOR_BASE_FORMAT_U8U8U8U8 | SCE_GXM_COLOR_SWIZZLE4_ABGR,
    SCE_GXM_COLOR_FORMAT_U8U8U8U8_ARGB = SCE_GXM_COLOR_BASE_FORMAT_U8U8U8U8 | SCE_GXM_COLOR_SWIZZLE4_ARGB,
    SCE_GXM_COLOR_FORMAT_U8U8U8U8_RGBA = SCE_GXM_COLOR_BASE_FORMAT_U8U8U8U8 | SCE_GXM_COLOR_SWIZZLE4_RGBA,
    SCE_GXM_COLOR_FORMAT_U8U8U8U8_BGRA = SCE_GXM_COLOR_BASE_FORMAT_U8U8U8U8 | SCE_GXM_COLOR_SWIZZLE4_BGRA,
    SCE_GXM_COLOR_FORMAT_U8U8U8_BGR = SCE_GXM_COLOR_BASE_FORMAT_U8U8U8 | SCE_GXM_COLOR_SWIZZLE3_BGR,
    SCE_GXM_COLOR_FORMAT_U8U8U8_RGB = SCE_GXM_COLOR_BASE_FORMAT_U8U8U8 | SCE_GXM_COLOR_SWIZZLE3_RGB,
    SCE_GXM_COLOR_FORMAT_U5U6U5_BGR = SCE_GXM_COLOR_BASE_FORMAT_U5U6U5 | SCE_GXM_COLOR_SWIZZLE3_BGR,
    SCE_GXM_COLOR_FORMAT_U5U6U5_RGB = SCE_GXM_COLOR_BASE_FORMAT_U5U6U5 | SCE_GXM_COLOR_SWIZZLE3_RGB,
    SCE_GXM_COLOR_FORMAT_U1U5U5U5_ABGR = SCE_GXM_COLOR_BASE_FORMAT_U1U5U5U5 | SCE_GXM_COLOR_SWIZZLE4_ABGR,
    SCE_GXM_COLOR_FORMAT_U1U5U5U5_ARGB = SCE_GXM_COLOR_BASE_FORMAT_U1U5U5U5 | SCE_GXM_COLOR_SWIZZLE4_ARGB,
    SCE_GXM_COLOR_FORMAT_U5U5U5U1_RGBA = SCE_GXM_COLOR_BASE_FORMAT_U1U5U5U5 | SCE_GXM_COLOR_SWIZZLE4_RGBA,
    SCE_GXM_COLOR_FORMAT_U5U5U5U1_BGRA = SCE_GXM_COLOR_BASE_FORMAT_U1U5U5U5 | SCE_GXM_COLOR_SWIZZLE4_BGRA,
    SCE_GXM_COLOR_FORMAT_U4U4U4U4_ABGR = SCE_GXM_COLOR_BASE_FORMAT_U4U4U4U4 | SCE_GXM_COLOR_SWIZZLE4_ABGR,
    SCE_GXM_COLOR_FORMAT_U4U4U4U4_ARGB = SCE_GXM_COLOR_BASE_FORMAT_U4U4U4U4 | SCE_GXM_COLOR_SWIZZLE4_ARGB,
    SCE_GXM_COLOR_FORMAT_U4U4U4U4_RGBA = SCE_GXM_COLOR_BASE_FORMAT_U4U4U4U4 | SCE_GXM_COLOR_SWIZZLE4_RGBA,
    SCE_GXM_COLOR_FORMAT_U4U4U4U4_BGRA = SCE_GXM_COLOR_BASE_FORMAT_U4U4U4U4 | SCE_GXM_COLOR_SWIZZLE4_BGRA,
    SCE_GXM_COLOR_FORMAT_U8U3U3U2_ARGB = SCE_GXM_COLOR_BASE_FORMAT_U8U3U3U2,
    SCE_GXM_COLOR_FORMAT_F16_R = SCE_GXM_COLOR_BASE_FORMAT_F16 | SCE_GXM_COLOR_SWIZZLE1_R,
    SCE_GXM_COLOR_FORMAT_F16_G = SCE_GXM_COLOR_BASE_FORMAT_F16 | SCE_GXM_COLOR_SWIZZLE1_G,
    SCE_GXM_COLOR_FORMAT_F16F16_GR = SCE_GXM_COLOR_BASE_FORMAT_F16F16 | SCE_GXM_COLOR_SWIZZLE2_GR,
    SCE_GXM_COLOR_FORMAT_F16F16_RG = SCE_GXM_COLOR_BASE_FORMAT_F16F16 | SCE_GXM_COLOR_SWIZZLE2_RG,
    SCE_GXM_COLOR_FORMAT_F32_R = SCE_GXM_COLOR_BASE_FORMAT_F32 | SCE_GXM_COLOR_SWIZZLE1_R,
    SCE_GXM_COLOR_FORMAT_S16_R = SCE_GXM_COLOR_BASE_FORMAT_S16 | SCE_GXM_COLOR_SWIZZLE1_R,
    SCE_GXM_COLOR_FORMAT_S16_G = SCE_GXM_COLOR_BASE_FORMAT_S16 | SCE_GXM_COLOR_SWIZZLE1_G,
    SCE_GXM_COLOR_FORMAT_S16S16_GR = SCE_GXM_COLOR_BASE_FORMAT_S16S16 | SCE_GXM_COLOR_SWIZZLE2_GR,
    SCE_GXM_COLOR_FORMAT_S16S16_RG = SCE_GXM_COLOR_BASE_FORMAT_S16S16 | SCE_GXM_COLOR_SWIZZLE2_RG,
    SCE_GXM_COLOR_FORMAT_U16_R = SCE_GXM_COLOR_BASE_FORMAT_U16 | SCE_GXM_COLOR_SWIZZLE1_R,
    SCE_GXM_COLOR_FORMAT_U16_G = SCE_GXM_COLOR_BASE_FORMAT_U16 | SCE_GXM_COLOR_SWIZZLE1_G,
    SCE_GXM_COLOR_FORMAT_U16U16_GR = SCE_GXM_COLOR_BASE_FORMAT_U16U16 | SCE_GXM_COLOR_SWIZZLE2_GR,
    SCE_GXM_COLOR_FORMAT_U16U16_RG = SCE_GXM_COLOR_BASE_FORMAT_U16U16 | SCE_GXM_COLOR_SWIZZLE2_RG,
    SCE_GXM_COLOR_FORMAT_U2U10U10U10_ABGR = SCE_GXM_COLOR_BASE_FORMAT_U2U10U10U10 | SCE_GXM_COLOR_SWIZZLE4_ABGR,
    SCE_GXM_COLOR_FORMAT_U2U10U10U10_ARGB = SCE_GXM_COLOR_BASE_FORMAT_U2U10U10U10 | SCE_GXM_COLOR_SWIZZLE4_ARGB,
    SCE_GXM_COLOR_FORMAT_U10U10U10U2_RGBA = SCE_GXM_COLOR_BASE_FORMAT_U2U10U10U10 | SCE_GXM_COLOR_SWIZZLE4_RGBA,
    SCE_GXM_COLOR_FORMAT_U10U10U10U2_BGRA = SCE_GXM_COLOR_BASE_FORMAT_U2U10U10U10 | SCE_GXM_COLOR_SWIZZLE4_BGRA,
    SCE_GXM_COLOR_FORMAT_U8_R = SCE_GXM_COLOR_BASE_FORMAT_U8 | SCE_GXM_COLOR_SWIZZLE1_R,
    SCE_GXM_COLOR_FORMAT_U8_A = SCE_GXM_COLOR_BASE_FORMAT_U8 | SCE_GXM_COLOR_SWIZZLE1_A,
    SCE_GXM_COLOR_FORMAT_S8_R = SCE_GXM_COLOR_BASE_FORMAT_S8 | SCE_GXM_COLOR_SWIZZLE1_R,
    SCE_GXM_COLOR_FORMAT_S8_A = SCE_GXM_COLOR_BASE_FORMAT_S8 | SCE_GXM_COLOR_SWIZZLE1_A,
    SCE_GXM_COLOR_FORMAT_U6S5S5_BGR = SCE_GXM_COLOR_BASE_FORMAT_S5S5U6 | SCE_GXM_COLOR_SWIZZLE3_BGR,
    SCE_GXM_COLOR_FORMAT_S5S5U6_RGB = SCE_GXM_COLOR_BASE_FORMAT_S5S5U6 | SCE_GXM_COLOR_SWIZZLE3_RGB,
    SCE_GXM_COLOR_FORMAT_U8U8_GR = SCE_GXM_COLOR_BASE_FORMAT_U8U8 | SCE_GXM_COLOR_SWIZZLE2_GR,
    SCE_GXM_COLOR_FORMAT_U8U8_RG = SCE_GXM_COLOR_BASE_FORMAT_U8U8 | SCE_GXM_COLOR_SWIZZLE2_RG,
    SCE_GXM_COLOR_FORMAT_U8U8_RA = SCE_GXM_COLOR_BASE_FORMAT_U8U8 | SCE_GXM_COLOR_SWIZZLE2_RA,
    SCE_GXM_COLOR_FORMAT_U8U8_AR = SCE_GXM_COLOR_BASE_FORMAT_U8U8 | SCE_GXM_COLOR_SWIZZLE2_AR,
    SCE_GXM_COLOR_FORMAT_S8S8_GR = SCE_GXM_COLOR_BASE_FORMAT_S8S8 | SCE_GXM_COLOR_SWIZZLE2_GR,
    SCE_GXM_COLOR_FORMAT_S8S8_RG = SCE_GXM_COLOR_BASE_FORMAT_S8S8 | SCE_GXM_COLOR_SWIZZLE2_RG,
    SCE_GXM_COLOR_FORMAT_S8S8_RA = SCE_GXM_COLOR_BASE_FORMAT_S8S8 | SCE_GXM_COLOR_SWIZZLE2_RA,
    SCE_GXM_COLOR_FORMAT_S8S8_AR = SCE_GXM_COLOR_BASE_FORMAT_S8S8 | SCE_GXM_COLOR_SWIZZLE2_AR,
    SCE_GXM_COLOR_FORMAT_U8S8S8U8_ABGR = SCE_GXM_COLOR_BASE_FORMAT_U8S8S8U8 | SCE_GXM_COLOR_SWIZZLE4_ABGR,
    SCE_GXM_COLOR_FORMAT_U8U8S8S8_ARGB = SCE_GXM_COLOR_BASE_FORMAT_U8S8S8U8 | SCE_GXM_COLOR_SWIZZLE4_ARGB,
    SCE_GXM_COLOR_FORMAT_U8S8S8U8_RGBA = SCE_GXM_COLOR_BASE_FORMAT_U8S8S8U8 | SCE_GXM_COLOR_SWIZZLE4_RGBA,
    SCE_GXM_COLOR_FORMAT_S8S8U8U8_BGRA = SCE_GXM_COLOR_BASE_FORMAT_U8S8S8U8 | SCE_GXM_COLOR_SWIZZLE4_BGRA,
    SCE_GXM_COLOR_FORMAT_S8S8S8S8_ABGR = SCE_GXM_COLOR_BASE_FORMAT_S8S8S8S8 | SCE_GXM_COLOR_SWIZZLE4_ABGR,
    SCE_GXM_COLOR_FORMAT_S8S8S8S8_ARGB = SCE_GXM_COLOR_BASE_FORMAT_S8S8S8S8 | SCE_GXM_COLOR_SWIZZLE4_ARGB,
    SCE_GXM_COLOR_FORMAT_S8S8S8S8_RGBA = SCE_GXM_COLOR_BASE_FORMAT_S8S8S8S8 | SCE_GXM_COLOR_SWIZZLE4_RGBA,
    SCE_GXM_COLOR_FORMAT_S8S8S8S8_BGRA = SCE_GXM_COLOR_BASE_FORMAT_S8S8S8S8 | SCE_GXM_COLOR_SWIZZLE4_BGRA,
    SCE_GXM_COLOR_FORMAT_F16F16F16F16_ABGR = SCE_GXM_COLOR_BASE_FORMAT_F16F16F16F16 | SCE_GXM_COLOR_SWIZZLE4_ABGR,
    SCE_GXM_COLOR_FORMAT_F16F16F16F16_ARGB = SCE_GXM_COLOR_BASE_FORMAT_F16F16F16F16 | SCE_GXM_COLOR_SWIZZLE4_ARGB,
    SCE_GXM_COLOR_FORMAT_F16F16F16F16_RGBA = SCE_GXM_COLOR_BASE_FORMAT_F16F16F16F16 | SCE_GXM_COLOR_SWIZZLE4_RGBA,
    SCE_GXM_COLOR_FORMAT_F16F16F16F16_BGRA = SCE_GXM_COLOR_BASE_FORMAT_F16F16F16F16 | SCE_GXM_COLOR_SWIZZLE4_BGRA,
    SCE_GXM_COLOR_FORMAT_F32F32_GR = SCE_GXM_COLOR_BASE_FORMAT_F32F32 | SCE_GXM_COLOR_SWIZZLE2_GR,
    SCE_GXM_COLOR_FORMAT_F32F32_RG = SCE_GXM_COLOR_BASE_FORMAT_F32F32 | SCE_GXM_COLOR_SWIZZLE2_RG,
    SCE_GXM_COLOR_FORMAT_F10F11F11_BGR = SCE_GXM_COLOR_BASE_FORMAT_F11F11F10 | SCE_GXM_COLOR_SWIZZLE3_BGR,
    SCE_GXM_COLOR_FORMAT_F11F11F10_RGB = SCE_GXM_COLOR_BASE_FORMAT_F11F11F10 | SCE_GXM_COLOR_SWIZZLE3_RGB,
    SCE_GXM_COLOR_FORMAT_SE5M9M9M9_BGR = SCE_GXM_COLOR_BASE_FORMAT_SE5M9M9M9 | SCE_GXM_COLOR_SWIZZLE3_BGR,
    SCE_GXM_COLOR_FORMAT_SE5M9M9M9_RGB = SCE_GXM_COLOR_BASE_FORMAT_SE5M9M9M9 | SCE_GXM_COLOR_SWIZZLE3_RGB,
    SCE_GXM_COLOR_FORMAT_U2F10F10F10_ABGR = SCE_GXM_COLOR_BASE_FORMAT_U2F10F10F10 | SCE_GXM_COLOR_SWIZZLE4_ABGR,
    SCE_GXM_COLOR_FORMAT_U2F10F10F10_ARGB = SCE_GXM_COLOR_BASE_FORMAT_U2F10F10F10 | SCE_GXM_COLOR_SWIZZLE4_ARGB,
    SCE_GXM_COLOR_FORMAT_F10F10F10U2_RGBA = SCE_GXM_COLOR_BASE_FORMAT_U2F10F10F10 | SCE_GXM_COLOR_SWIZZLE4_RGBA,
    SCE_GXM_COLOR_FORMAT_F10F10F10U2_BGRA = SCE_GXM_COLOR_BASE_FORMAT_U2F10F10F10 | SCE_GXM_COLOR_SWIZZLE4_BGRA,
    SCE_GXM_COLOR_FORMAT_A8B8G8R8 = SCE_GXM_COLOR_FORMAT_U8U8U8U8_ABGR,
    SCE_GXM_COLOR_FORMAT_A8R8G8B8 = SCE_GXM_COLOR_FORMAT_U8U8U8U8_ARGB,
    SCE_GXM_COLOR_FORMAT_R5G6B5 = SCE_GXM_COLOR_FORMAT_U5U6U5_RGB,
    SCE_GXM_COLOR_FORMAT_A1R5G5B5 = SCE_GXM_COLOR_FORMAT_U1U5U5U5_ARGB,
    SCE_GXM_COLOR_FORMAT_A4R4G4B4 = SCE_GXM_COLOR_FORMAT_U4U4U4U4_ARGB,
    SCE_GXM_COLOR_FORMAT_A8 = SCE_GXM_COLOR_FORMAT_U8_A
};

enum SceGxmTextureBaseFormat
{
    SCE_GXM_TEXTURE_BASE_FORMAT_U8 = 0x00000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_S8 = 0x01000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4 = 0x02000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U8U3U3U2 = 0x03000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5 = 0x04000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U5U6U5 = 0x05000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_S5S5U6 = 0x06000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U8U8 = 0x07000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_S8S8 = 0x08000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U16 = 0x09000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_S16 = 0x0a000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_F16 = 0x0b000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8 = 0x0c000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8 = 0x0d000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10 = 0x0e000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U16U16 = 0x0f000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_S16S16 = 0x10000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_F16F16 = 0x11000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_F32 = 0x12000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_F32M = 0x13000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_X8S8S8U8 = 0x14000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_X8U24 = 0x15000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U32 = 0x17000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_S32 = 0x18000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_SE5M9M9M9 = 0x19000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_F11F11F10 = 0x1a000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16 = 0x1b000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16 = 0x1c000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16 = 0x1d000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_F32F32 = 0x1e000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U32U32 = 0x1f000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_PVRT2BPP = 0x80000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_PVRT4BPP = 0x81000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII2BPP = 0x82000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII4BPP = 0x83000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_UBC1 = 0x85000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_UBC2 = 0x86000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_UBC3 = 0x87000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P2 = 0x90000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P3 = 0x91000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_YUV422 = 0x92000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_P4 = 0x94000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_P8 = 0x95000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8 = 0x98000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8 = 0x99000000,
    SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 = 0x9a000000
};

enum SceGxmTextureSwizzle1Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_TEXTURE_SWIZZLE1_R = 0x00000000,
    SCE_GXM_TEXTURE_SWIZZLE1_000R = 0x00001000,
    SCE_GXM_TEXTURE_SWIZZLE1_111R = 0x00002000,
    SCE_GXM_TEXTURE_SWIZZLE1_RRRR = 0x00003000,
    SCE_GXM_TEXTURE_SWIZZLE1_0RRR = 0x00004000,
    SCE_GXM_TEXTURE_SWIZZLE1_1RRR = 0x00005000,
    SCE_GXM_TEXTURE_SWIZZLE1_R000 = 0x00006000,
    SCE_GXM_TEXTURE_SWIZZLE1_R111 = 0x00007000
};

enum SceGxmTextureSwizzle2Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_TEXTURE_SWIZZLE2_GR = 0x00000000,
    SCE_GXM_TEXTURE_SWIZZLE2_00GR = 0x00001000,
    SCE_GXM_TEXTURE_SWIZZLE2_GRRR = 0x00002000,
    SCE_GXM_TEXTURE_SWIZZLE2_RGGG = 0x00003000,
    SCE_GXM_TEXTURE_SWIZZLE2_GRGR = 0x00004000,
    SCE_GXM_TEXTURE_SWIZZLE2_00RG = 0x00005000
};

enum SceGxmTextureSwizzle2ModeAlt
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_TEXTURE_SWIZZLE2_SD = 0x00000000,
    SCE_GXM_TEXTURE_SWIZZLE2_DS = 0x00001000
};

enum SceGxmTextureSwizzle3Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_TEXTURE_SWIZZLE3_BGR = 0x00000000,
    SCE_GXM_TEXTURE_SWIZZLE3_RGB = 0x00001000
};

enum SceGxmTextureSwizzle4Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_TEXTURE_SWIZZLE4_ABGR = 0x00000000,
    SCE_GXM_TEXTURE_SWIZZLE4_ARGB = 0x00001000,
    SCE_GXM_TEXTURE_SWIZZLE4_RGBA = 0x00002000,
    SCE_GXM_TEXTURE_SWIZZLE4_BGRA = 0x00003000,
    SCE_GXM_TEXTURE_SWIZZLE4_1BGR = 0x00004000,
    SCE_GXM_TEXTURE_SWIZZLE4_1RGB = 0x00005000,
    SCE_GXM_TEXTURE_SWIZZLE4_RGB1 = 0x00006000,
    SCE_GXM_TEXTURE_SWIZZLE4_BGR1 = 0x00007000
};

enum SceGxmTextureSwizzleYUV420Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_TEXTURE_SWIZZLE_YUV_CSC0 = 0x00000000,
    SCE_GXM_TEXTURE_SWIZZLE_YVU_CSC0 = 0x00001000,
    SCE_GXM_TEXTURE_SWIZZLE_YUV_CSC1 = 0x00002000,
    SCE_GXM_TEXTURE_SWIZZLE_YVU_CSC1 = 0x00003000
};

enum SceGxmTextureSwizzleYUV422Mode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_TEXTURE_SWIZZLE_YUYV_CSC0 = 0x00000000,
    SCE_GXM_TEXTURE_SWIZZLE_YVYU_CSC0 = 0x00001000,
    SCE_GXM_TEXTURE_SWIZZLE_UYVY_CSC0 = 0x00002000,
    SCE_GXM_TEXTURE_SWIZZLE_VYUY_CSC0 = 0x00003000,
    SCE_GXM_TEXTURE_SWIZZLE_YUYV_CSC1 = 0x00004000,
    SCE_GXM_TEXTURE_SWIZZLE_YVYU_CSC1 = 0x00005000,
    SCE_GXM_TEXTURE_SWIZZLE_UYVY_CSC1 = 0x00006000,
    SCE_GXM_TEXTURE_SWIZZLE_VYUY_CSC1 = 0x00007000
};

enum SceGxmTextureFormat
{
    // https://psp2sdk.github.io/gxm_8h_source.html
    SCE_GXM_TEXTURE_FORMAT_U8_000R = SCE_GXM_TEXTURE_BASE_FORMAT_U8 | SCE_GXM_TEXTURE_SWIZZLE1_000R,
    SCE_GXM_TEXTURE_FORMAT_U8_111R = SCE_GXM_TEXTURE_BASE_FORMAT_U8 | SCE_GXM_TEXTURE_SWIZZLE1_111R,
    SCE_GXM_TEXTURE_FORMAT_U8_RRRR = SCE_GXM_TEXTURE_BASE_FORMAT_U8 | SCE_GXM_TEXTURE_SWIZZLE1_RRRR,
    SCE_GXM_TEXTURE_FORMAT_U8_0RRR = SCE_GXM_TEXTURE_BASE_FORMAT_U8 | SCE_GXM_TEXTURE_SWIZZLE1_0RRR,
    SCE_GXM_TEXTURE_FORMAT_U8_1RRR = SCE_GXM_TEXTURE_BASE_FORMAT_U8 | SCE_GXM_TEXTURE_SWIZZLE1_1RRR,
    SCE_GXM_TEXTURE_FORMAT_U8_R000 = SCE_GXM_TEXTURE_BASE_FORMAT_U8 | SCE_GXM_TEXTURE_SWIZZLE1_R000,
    SCE_GXM_TEXTURE_FORMAT_U8_R111 = SCE_GXM_TEXTURE_BASE_FORMAT_U8 | SCE_GXM_TEXTURE_SWIZZLE1_R111,
    SCE_GXM_TEXTURE_FORMAT_U8_R = SCE_GXM_TEXTURE_BASE_FORMAT_U8 | SCE_GXM_TEXTURE_SWIZZLE1_R,
    SCE_GXM_TEXTURE_FORMAT_S8_000R = SCE_GXM_TEXTURE_BASE_FORMAT_S8 | SCE_GXM_TEXTURE_SWIZZLE1_000R,
    SCE_GXM_TEXTURE_FORMAT_S8_111R = SCE_GXM_TEXTURE_BASE_FORMAT_S8 | SCE_GXM_TEXTURE_SWIZZLE1_111R,
    SCE_GXM_TEXTURE_FORMAT_S8_RRRR = SCE_GXM_TEXTURE_BASE_FORMAT_S8 | SCE_GXM_TEXTURE_SWIZZLE1_RRRR,
    SCE_GXM_TEXTURE_FORMAT_S8_0RRR = SCE_GXM_TEXTURE_BASE_FORMAT_S8 | SCE_GXM_TEXTURE_SWIZZLE1_0RRR,
    SCE_GXM_TEXTURE_FORMAT_S8_1RRR = SCE_GXM_TEXTURE_BASE_FORMAT_S8 | SCE_GXM_TEXTURE_SWIZZLE1_1RRR,
    SCE_GXM_TEXTURE_FORMAT_S8_R000 = SCE_GXM_TEXTURE_BASE_FORMAT_S8 | SCE_GXM_TEXTURE_SWIZZLE1_R000,
    SCE_GXM_TEXTURE_FORMAT_S8_R111 = SCE_GXM_TEXTURE_BASE_FORMAT_S8 | SCE_GXM_TEXTURE_SWIZZLE1_R111,
    SCE_GXM_TEXTURE_FORMAT_S8_R = SCE_GXM_TEXTURE_BASE_FORMAT_S8 | SCE_GXM_TEXTURE_SWIZZLE1_R,
    SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_X4U4U4U4_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_X4U4U4U4_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_U4U4U4X4_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_U4U4U4X4_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_U4U4U4U4 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_U8U3U3U2_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_U8U3U3U2,
    SCE_GXM_TEXTURE_FORMAT_U1U5U5U5_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_U1U5U5U5_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_U5U5U5U1_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_U5U5U5U1_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_X1U5U5U5_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_X1U5U5U5_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_U5U5U5X1_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_U5U5U5X1_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_U1U5U5U5 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_U5U6U5_BGR = SCE_GXM_TEXTURE_BASE_FORMAT_U5U6U5 | SCE_GXM_TEXTURE_SWIZZLE3_BGR,
    SCE_GXM_TEXTURE_FORMAT_U5U6U5_RGB = SCE_GXM_TEXTURE_BASE_FORMAT_U5U6U5 | SCE_GXM_TEXTURE_SWIZZLE3_RGB,
    SCE_GXM_TEXTURE_FORMAT_U6S5S5_BGR = SCE_GXM_TEXTURE_BASE_FORMAT_S5S5U6 | SCE_GXM_TEXTURE_SWIZZLE3_BGR,
    SCE_GXM_TEXTURE_FORMAT_S5S5U6_RGB = SCE_GXM_TEXTURE_BASE_FORMAT_S5S5U6 | SCE_GXM_TEXTURE_SWIZZLE3_RGB,
    SCE_GXM_TEXTURE_FORMAT_U8U8_00GR = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8 | SCE_GXM_TEXTURE_SWIZZLE2_00GR,
    SCE_GXM_TEXTURE_FORMAT_U8U8_GRRR = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8 | SCE_GXM_TEXTURE_SWIZZLE2_GRRR,
    SCE_GXM_TEXTURE_FORMAT_U8U8_RGGG = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8 | SCE_GXM_TEXTURE_SWIZZLE2_RGGG,
    SCE_GXM_TEXTURE_FORMAT_U8U8_GRGR = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8 | SCE_GXM_TEXTURE_SWIZZLE2_GRGR,
    SCE_GXM_TEXTURE_FORMAT_U8U8_00RG = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8 | SCE_GXM_TEXTURE_SWIZZLE2_00RG,
    SCE_GXM_TEXTURE_FORMAT_U8U8_GR = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8 | SCE_GXM_TEXTURE_SWIZZLE2_GR,
    SCE_GXM_TEXTURE_FORMAT_S8S8_00GR = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8 | SCE_GXM_TEXTURE_SWIZZLE2_00GR,
    SCE_GXM_TEXTURE_FORMAT_S8S8_GRRR = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8 | SCE_GXM_TEXTURE_SWIZZLE2_GRRR,
    SCE_GXM_TEXTURE_FORMAT_S8S8_RGGG = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8 | SCE_GXM_TEXTURE_SWIZZLE2_RGGG,
    SCE_GXM_TEXTURE_FORMAT_S8S8_GRGR = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8 | SCE_GXM_TEXTURE_SWIZZLE2_GRGR,
    SCE_GXM_TEXTURE_FORMAT_S8S8_00RG = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8 | SCE_GXM_TEXTURE_SWIZZLE2_00RG,
    SCE_GXM_TEXTURE_FORMAT_S8S8_GR = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8 | SCE_GXM_TEXTURE_SWIZZLE2_GR,
    SCE_GXM_TEXTURE_FORMAT_U16_000R = SCE_GXM_TEXTURE_BASE_FORMAT_U16 | SCE_GXM_TEXTURE_SWIZZLE1_000R,
    SCE_GXM_TEXTURE_FORMAT_U16_111R = SCE_GXM_TEXTURE_BASE_FORMAT_U16 | SCE_GXM_TEXTURE_SWIZZLE1_111R,
    SCE_GXM_TEXTURE_FORMAT_U16_RRRR = SCE_GXM_TEXTURE_BASE_FORMAT_U16 | SCE_GXM_TEXTURE_SWIZZLE1_RRRR,
    SCE_GXM_TEXTURE_FORMAT_U16_0RRR = SCE_GXM_TEXTURE_BASE_FORMAT_U16 | SCE_GXM_TEXTURE_SWIZZLE1_0RRR,
    SCE_GXM_TEXTURE_FORMAT_U16_1RRR = SCE_GXM_TEXTURE_BASE_FORMAT_U16 | SCE_GXM_TEXTURE_SWIZZLE1_1RRR,
    SCE_GXM_TEXTURE_FORMAT_U16_R000 = SCE_GXM_TEXTURE_BASE_FORMAT_U16 | SCE_GXM_TEXTURE_SWIZZLE1_R000,
    SCE_GXM_TEXTURE_FORMAT_U16_R111 = SCE_GXM_TEXTURE_BASE_FORMAT_U16 | SCE_GXM_TEXTURE_SWIZZLE1_R111,
    SCE_GXM_TEXTURE_FORMAT_U16_R = SCE_GXM_TEXTURE_BASE_FORMAT_U16 | SCE_GXM_TEXTURE_SWIZZLE1_R,
    SCE_GXM_TEXTURE_FORMAT_S16_000R = SCE_GXM_TEXTURE_BASE_FORMAT_S16 | SCE_GXM_TEXTURE_SWIZZLE1_000R,
    SCE_GXM_TEXTURE_FORMAT_S16_111R = SCE_GXM_TEXTURE_BASE_FORMAT_S16 | SCE_GXM_TEXTURE_SWIZZLE1_111R,
    SCE_GXM_TEXTURE_FORMAT_S16_RRRR = SCE_GXM_TEXTURE_BASE_FORMAT_S16 | SCE_GXM_TEXTURE_SWIZZLE1_RRRR,
    SCE_GXM_TEXTURE_FORMAT_S16_0RRR = SCE_GXM_TEXTURE_BASE_FORMAT_S16 | SCE_GXM_TEXTURE_SWIZZLE1_0RRR,
    SCE_GXM_TEXTURE_FORMAT_S16_1RRR = SCE_GXM_TEXTURE_BASE_FORMAT_S16 | SCE_GXM_TEXTURE_SWIZZLE1_1RRR,
    SCE_GXM_TEXTURE_FORMAT_S16_R000 = SCE_GXM_TEXTURE_BASE_FORMAT_S16 | SCE_GXM_TEXTURE_SWIZZLE1_R000,
    SCE_GXM_TEXTURE_FORMAT_S16_R111 = SCE_GXM_TEXTURE_BASE_FORMAT_S16 | SCE_GXM_TEXTURE_SWIZZLE1_R111,
    SCE_GXM_TEXTURE_FORMAT_S16_R = SCE_GXM_TEXTURE_BASE_FORMAT_S16 | SCE_GXM_TEXTURE_SWIZZLE1_R,
    SCE_GXM_TEXTURE_FORMAT_F16_000R = SCE_GXM_TEXTURE_BASE_FORMAT_F16 | SCE_GXM_TEXTURE_SWIZZLE1_000R,
    SCE_GXM_TEXTURE_FORMAT_F16_111R = SCE_GXM_TEXTURE_BASE_FORMAT_F16 | SCE_GXM_TEXTURE_SWIZZLE1_111R,
    SCE_GXM_TEXTURE_FORMAT_F16_RRRR = SCE_GXM_TEXTURE_BASE_FORMAT_F16 | SCE_GXM_TEXTURE_SWIZZLE1_RRRR,
    SCE_GXM_TEXTURE_FORMAT_F16_0RRR = SCE_GXM_TEXTURE_BASE_FORMAT_F16 | SCE_GXM_TEXTURE_SWIZZLE1_0RRR,
    SCE_GXM_TEXTURE_FORMAT_F16_1RRR = SCE_GXM_TEXTURE_BASE_FORMAT_F16 | SCE_GXM_TEXTURE_SWIZZLE1_1RRR,
    SCE_GXM_TEXTURE_FORMAT_F16_R000 = SCE_GXM_TEXTURE_BASE_FORMAT_F16 | SCE_GXM_TEXTURE_SWIZZLE1_R000,
    SCE_GXM_TEXTURE_FORMAT_F16_R111 = SCE_GXM_TEXTURE_BASE_FORMAT_F16 | SCE_GXM_TEXTURE_SWIZZLE1_R111,
    SCE_GXM_TEXTURE_FORMAT_F16_R = SCE_GXM_TEXTURE_BASE_FORMAT_F16 | SCE_GXM_TEXTURE_SWIZZLE1_R,
    SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_X8U8U8U8_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_X8U8U8U8_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_U8U8U8X8_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_U8U8U8X8_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_S8S8S8S8_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_S8S8S8S8_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_S8S8S8S8_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_S8S8S8S8_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_X8S8S8S8_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_X8S8S8S8_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_S8S8S8X8_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_S8S8S8X8_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_U2U10U10U10_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_U2U10U10U10_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_U10U10U10U2_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_U10U10U10U2_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_X2U10U10U10_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_X2U10U10U10_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_U10U10U10X2_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_U10U10U10X2_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_U2U10U10U10 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_U16U16_00GR = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16 | SCE_GXM_TEXTURE_SWIZZLE2_00GR,
    SCE_GXM_TEXTURE_FORMAT_U16U16_GRRR = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16 | SCE_GXM_TEXTURE_SWIZZLE2_GRRR,
    SCE_GXM_TEXTURE_FORMAT_U16U16_RGGG = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16 | SCE_GXM_TEXTURE_SWIZZLE2_RGGG,
    SCE_GXM_TEXTURE_FORMAT_U16U16_GRGR = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16 | SCE_GXM_TEXTURE_SWIZZLE2_GRGR,
    SCE_GXM_TEXTURE_FORMAT_U16U16_00RG = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16 | SCE_GXM_TEXTURE_SWIZZLE2_00RG,
    SCE_GXM_TEXTURE_FORMAT_U16U16_GR = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16 | SCE_GXM_TEXTURE_SWIZZLE2_GR,
    SCE_GXM_TEXTURE_FORMAT_S16S16_00GR = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16 | SCE_GXM_TEXTURE_SWIZZLE2_00GR,
    SCE_GXM_TEXTURE_FORMAT_S16S16_GRRR = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16 | SCE_GXM_TEXTURE_SWIZZLE2_GRRR,
    SCE_GXM_TEXTURE_FORMAT_S16S16_RGGG = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16 | SCE_GXM_TEXTURE_SWIZZLE2_RGGG,
    SCE_GXM_TEXTURE_FORMAT_S16S16_GRGR = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16 | SCE_GXM_TEXTURE_SWIZZLE2_GRGR,
    SCE_GXM_TEXTURE_FORMAT_S16S16_00RG = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16 | SCE_GXM_TEXTURE_SWIZZLE2_00RG,
    SCE_GXM_TEXTURE_FORMAT_S16S16_GR = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16 | SCE_GXM_TEXTURE_SWIZZLE2_GR,
    SCE_GXM_TEXTURE_FORMAT_F16F16_00GR = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16 | SCE_GXM_TEXTURE_SWIZZLE2_00GR,
    SCE_GXM_TEXTURE_FORMAT_F16F16_GRRR = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16 | SCE_GXM_TEXTURE_SWIZZLE2_GRRR,
    SCE_GXM_TEXTURE_FORMAT_F16F16_RGGG = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16 | SCE_GXM_TEXTURE_SWIZZLE2_RGGG,
    SCE_GXM_TEXTURE_FORMAT_F16F16_GRGR = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16 | SCE_GXM_TEXTURE_SWIZZLE2_GRGR,
    SCE_GXM_TEXTURE_FORMAT_F16F16_00RG = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16 | SCE_GXM_TEXTURE_SWIZZLE2_00RG,
    SCE_GXM_TEXTURE_FORMAT_F16F16_GR = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16 | SCE_GXM_TEXTURE_SWIZZLE2_GR,
    SCE_GXM_TEXTURE_FORMAT_F32_000R = SCE_GXM_TEXTURE_BASE_FORMAT_F32 | SCE_GXM_TEXTURE_SWIZZLE1_000R,
    SCE_GXM_TEXTURE_FORMAT_F32_111R = SCE_GXM_TEXTURE_BASE_FORMAT_F32 | SCE_GXM_TEXTURE_SWIZZLE1_111R,
    SCE_GXM_TEXTURE_FORMAT_F32_RRRR = SCE_GXM_TEXTURE_BASE_FORMAT_F32 | SCE_GXM_TEXTURE_SWIZZLE1_RRRR,
    SCE_GXM_TEXTURE_FORMAT_F32_0RRR = SCE_GXM_TEXTURE_BASE_FORMAT_F32 | SCE_GXM_TEXTURE_SWIZZLE1_0RRR,
    SCE_GXM_TEXTURE_FORMAT_F32_1RRR = SCE_GXM_TEXTURE_BASE_FORMAT_F32 | SCE_GXM_TEXTURE_SWIZZLE1_1RRR,
    SCE_GXM_TEXTURE_FORMAT_F32_R000 = SCE_GXM_TEXTURE_BASE_FORMAT_F32 | SCE_GXM_TEXTURE_SWIZZLE1_R000,
    SCE_GXM_TEXTURE_FORMAT_F32_R111 = SCE_GXM_TEXTURE_BASE_FORMAT_F32 | SCE_GXM_TEXTURE_SWIZZLE1_R111,
    SCE_GXM_TEXTURE_FORMAT_F32_R = SCE_GXM_TEXTURE_BASE_FORMAT_F32 | SCE_GXM_TEXTURE_SWIZZLE1_R,
    SCE_GXM_TEXTURE_FORMAT_F32M_000R = SCE_GXM_TEXTURE_BASE_FORMAT_F32M | SCE_GXM_TEXTURE_SWIZZLE1_000R,
    SCE_GXM_TEXTURE_FORMAT_F32M_111R = SCE_GXM_TEXTURE_BASE_FORMAT_F32M | SCE_GXM_TEXTURE_SWIZZLE1_111R,
    SCE_GXM_TEXTURE_FORMAT_F32M_RRRR = SCE_GXM_TEXTURE_BASE_FORMAT_F32M | SCE_GXM_TEXTURE_SWIZZLE1_RRRR,
    SCE_GXM_TEXTURE_FORMAT_F32M_0RRR = SCE_GXM_TEXTURE_BASE_FORMAT_F32M | SCE_GXM_TEXTURE_SWIZZLE1_0RRR,
    SCE_GXM_TEXTURE_FORMAT_F32M_1RRR = SCE_GXM_TEXTURE_BASE_FORMAT_F32M | SCE_GXM_TEXTURE_SWIZZLE1_1RRR,
    SCE_GXM_TEXTURE_FORMAT_F32M_R000 = SCE_GXM_TEXTURE_BASE_FORMAT_F32M | SCE_GXM_TEXTURE_SWIZZLE1_R000,
    SCE_GXM_TEXTURE_FORMAT_F32M_R111 = SCE_GXM_TEXTURE_BASE_FORMAT_F32M | SCE_GXM_TEXTURE_SWIZZLE1_R111,
    SCE_GXM_TEXTURE_FORMAT_F32M_R = SCE_GXM_TEXTURE_BASE_FORMAT_F32M | SCE_GXM_TEXTURE_SWIZZLE1_R,
    SCE_GXM_TEXTURE_FORMAT_X8S8S8U8_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_X8S8S8U8 | SCE_GXM_TEXTURE_SWIZZLE3_BGR,
    SCE_GXM_TEXTURE_FORMAT_X8U8S8S8_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_X8S8S8U8 | SCE_GXM_TEXTURE_SWIZZLE3_RGB,
    SCE_GXM_TEXTURE_FORMAT_X8U24_SD = SCE_GXM_TEXTURE_BASE_FORMAT_X8U24 | SCE_GXM_TEXTURE_SWIZZLE2_SD,
    SCE_GXM_TEXTURE_FORMAT_U24X8_DS = SCE_GXM_TEXTURE_BASE_FORMAT_X8U24 | SCE_GXM_TEXTURE_SWIZZLE2_DS,
    SCE_GXM_TEXTURE_FORMAT_U32_000R = SCE_GXM_TEXTURE_BASE_FORMAT_U32 | SCE_GXM_TEXTURE_SWIZZLE1_000R,
    SCE_GXM_TEXTURE_FORMAT_U32_111R = SCE_GXM_TEXTURE_BASE_FORMAT_U32 | SCE_GXM_TEXTURE_SWIZZLE1_111R,
    SCE_GXM_TEXTURE_FORMAT_U32_RRRR = SCE_GXM_TEXTURE_BASE_FORMAT_U32 | SCE_GXM_TEXTURE_SWIZZLE1_RRRR,
    SCE_GXM_TEXTURE_FORMAT_U32_0RRR = SCE_GXM_TEXTURE_BASE_FORMAT_U32 | SCE_GXM_TEXTURE_SWIZZLE1_0RRR,
    SCE_GXM_TEXTURE_FORMAT_U32_1RRR = SCE_GXM_TEXTURE_BASE_FORMAT_U32 | SCE_GXM_TEXTURE_SWIZZLE1_1RRR,
    SCE_GXM_TEXTURE_FORMAT_U32_R000 = SCE_GXM_TEXTURE_BASE_FORMAT_U32 | SCE_GXM_TEXTURE_SWIZZLE1_R000,
    SCE_GXM_TEXTURE_FORMAT_U32_R111 = SCE_GXM_TEXTURE_BASE_FORMAT_U32 | SCE_GXM_TEXTURE_SWIZZLE1_R111,
    SCE_GXM_TEXTURE_FORMAT_U32_R = SCE_GXM_TEXTURE_BASE_FORMAT_U32 | SCE_GXM_TEXTURE_SWIZZLE1_R,
    SCE_GXM_TEXTURE_FORMAT_S32_000R = SCE_GXM_TEXTURE_BASE_FORMAT_S32 | SCE_GXM_TEXTURE_SWIZZLE1_000R,
    SCE_GXM_TEXTURE_FORMAT_S32_111R = SCE_GXM_TEXTURE_BASE_FORMAT_S32 | SCE_GXM_TEXTURE_SWIZZLE1_111R,
    SCE_GXM_TEXTURE_FORMAT_S32_RRRR = SCE_GXM_TEXTURE_BASE_FORMAT_S32 | SCE_GXM_TEXTURE_SWIZZLE1_RRRR,
    SCE_GXM_TEXTURE_FORMAT_S32_0RRR = SCE_GXM_TEXTURE_BASE_FORMAT_S32 | SCE_GXM_TEXTURE_SWIZZLE1_0RRR,
    SCE_GXM_TEXTURE_FORMAT_S32_1RRR = SCE_GXM_TEXTURE_BASE_FORMAT_S32 | SCE_GXM_TEXTURE_SWIZZLE1_1RRR,
    SCE_GXM_TEXTURE_FORMAT_S32_R000 = SCE_GXM_TEXTURE_BASE_FORMAT_S32 | SCE_GXM_TEXTURE_SWIZZLE1_R000,
    SCE_GXM_TEXTURE_FORMAT_S32_R111 = SCE_GXM_TEXTURE_BASE_FORMAT_S32 | SCE_GXM_TEXTURE_SWIZZLE1_R111,
    SCE_GXM_TEXTURE_FORMAT_S32_R = SCE_GXM_TEXTURE_BASE_FORMAT_S32 | SCE_GXM_TEXTURE_SWIZZLE1_R,
    SCE_GXM_TEXTURE_FORMAT_SE5M9M9M9_BGR = SCE_GXM_TEXTURE_BASE_FORMAT_SE5M9M9M9 | SCE_GXM_TEXTURE_SWIZZLE3_BGR,
    SCE_GXM_TEXTURE_FORMAT_SE5M9M9M9_RGB = SCE_GXM_TEXTURE_BASE_FORMAT_SE5M9M9M9 | SCE_GXM_TEXTURE_SWIZZLE3_RGB,
    SCE_GXM_TEXTURE_FORMAT_F10F11F11_BGR = SCE_GXM_TEXTURE_BASE_FORMAT_F11F11F10 | SCE_GXM_TEXTURE_SWIZZLE3_BGR,
    SCE_GXM_TEXTURE_FORMAT_F11F11F10_RGB = SCE_GXM_TEXTURE_BASE_FORMAT_F11F11F10 | SCE_GXM_TEXTURE_SWIZZLE3_RGB,
    SCE_GXM_TEXTURE_FORMAT_F16F16F16F16_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_F16F16F16F16_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_F16F16F16F16_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_F16F16F16F16_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_X16F16F16F16_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_X16F16F16F16_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_F16F16F16X16_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_F16F16F16X16_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_F16F16F16F16 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_U16U16U16U16_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_U16U16U16U16_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_U16U16U16U16_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_U16U16U16U16_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_X16U16U16U16_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_X16U16U16U16_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_U16U16U16X16_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_U16U16U16X16_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_U16U16U16U16 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_S16S16S16S16_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_S16S16S16S16_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_S16S16S16S16_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_S16S16S16S16_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_X16S16S16S16_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_X16S16S16S16_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_S16S16S16X16_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_S16S16S16X16_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_S16S16S16S16 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_F32F32_00GR = SCE_GXM_TEXTURE_BASE_FORMAT_F32F32 | SCE_GXM_TEXTURE_SWIZZLE2_00GR,
    SCE_GXM_TEXTURE_FORMAT_F32F32_GRRR = SCE_GXM_TEXTURE_BASE_FORMAT_F32F32 | SCE_GXM_TEXTURE_SWIZZLE2_GRRR,
    SCE_GXM_TEXTURE_FORMAT_F32F32_RGGG = SCE_GXM_TEXTURE_BASE_FORMAT_F32F32 | SCE_GXM_TEXTURE_SWIZZLE2_RGGG,
    SCE_GXM_TEXTURE_FORMAT_F32F32_GRGR = SCE_GXM_TEXTURE_BASE_FORMAT_F32F32 | SCE_GXM_TEXTURE_SWIZZLE2_GRGR,
    SCE_GXM_TEXTURE_FORMAT_F32F32_00RG = SCE_GXM_TEXTURE_BASE_FORMAT_F32F32 | SCE_GXM_TEXTURE_SWIZZLE2_00RG,
    SCE_GXM_TEXTURE_FORMAT_F32F32_GR = SCE_GXM_TEXTURE_BASE_FORMAT_F32F32 | SCE_GXM_TEXTURE_SWIZZLE2_GR,
    SCE_GXM_TEXTURE_FORMAT_U32U32_00GR = SCE_GXM_TEXTURE_BASE_FORMAT_U32U32 | SCE_GXM_TEXTURE_SWIZZLE2_00GR,
    SCE_GXM_TEXTURE_FORMAT_U32U32_GRRR = SCE_GXM_TEXTURE_BASE_FORMAT_U32U32 | SCE_GXM_TEXTURE_SWIZZLE2_GRRR,
    SCE_GXM_TEXTURE_FORMAT_U32U32_RGGG = SCE_GXM_TEXTURE_BASE_FORMAT_U32U32 | SCE_GXM_TEXTURE_SWIZZLE2_RGGG,
    SCE_GXM_TEXTURE_FORMAT_U32U32_GRGR = SCE_GXM_TEXTURE_BASE_FORMAT_U32U32 | SCE_GXM_TEXTURE_SWIZZLE2_GRGR,
    SCE_GXM_TEXTURE_FORMAT_U32U32_00RG = SCE_GXM_TEXTURE_BASE_FORMAT_U32U32 | SCE_GXM_TEXTURE_SWIZZLE2_00RG,
    SCE_GXM_TEXTURE_FORMAT_U32U32_GR = SCE_GXM_TEXTURE_BASE_FORMAT_U32U32 | SCE_GXM_TEXTURE_SWIZZLE2_GR,
    SCE_GXM_TEXTURE_FORMAT_PVRT2BPP_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_PVRT2BPP | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_PVRT2BPP_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_PVRT2BPP | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_PVRT4BPP_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_PVRT4BPP | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_PVRT4BPP_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_PVRT4BPP | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_PVRTII2BPP_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII2BPP | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_PVRTII2BPP_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII2BPP | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_PVRTII4BPP_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII4BPP | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_PVRTII4BPP_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_PVRTII4BPP | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_UBC1_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_UBC1 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_UBC2_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_UBC2 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_UBC3_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_UBC3 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_YUV420P2_CSC0 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P2 | SCE_GXM_TEXTURE_SWIZZLE_YUV_CSC0,
    SCE_GXM_TEXTURE_FORMAT_YVU420P2_CSC0 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P2 | SCE_GXM_TEXTURE_SWIZZLE_YVU_CSC0,
    SCE_GXM_TEXTURE_FORMAT_YUV420P2_CSC1 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P2 | SCE_GXM_TEXTURE_SWIZZLE_YUV_CSC1,
    SCE_GXM_TEXTURE_FORMAT_YVU420P2_CSC1 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P2 | SCE_GXM_TEXTURE_SWIZZLE_YVU_CSC1,
    SCE_GXM_TEXTURE_FORMAT_YUV420P3_CSC0 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P3 | SCE_GXM_TEXTURE_SWIZZLE_YUV_CSC0,
    SCE_GXM_TEXTURE_FORMAT_YVU420P3_CSC0 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P3 | SCE_GXM_TEXTURE_SWIZZLE_YVU_CSC0,
    SCE_GXM_TEXTURE_FORMAT_YUV420P3_CSC1 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P3 | SCE_GXM_TEXTURE_SWIZZLE_YUV_CSC1,
    SCE_GXM_TEXTURE_FORMAT_YVU420P3_CSC1 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV420P3 | SCE_GXM_TEXTURE_SWIZZLE_YVU_CSC1,
    SCE_GXM_TEXTURE_FORMAT_YUYV422_CSC0 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV422 | SCE_GXM_TEXTURE_SWIZZLE_YUYV_CSC0,
    SCE_GXM_TEXTURE_FORMAT_YVYU422_CSC0 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV422 | SCE_GXM_TEXTURE_SWIZZLE_YVYU_CSC0,
    SCE_GXM_TEXTURE_FORMAT_UYVY422_CSC0 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV422 | SCE_GXM_TEXTURE_SWIZZLE_UYVY_CSC0,
    SCE_GXM_TEXTURE_FORMAT_VYUY422_CSC0 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV422 | SCE_GXM_TEXTURE_SWIZZLE_VYUY_CSC0,
    SCE_GXM_TEXTURE_FORMAT_YUYV422_CSC1 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV422 | SCE_GXM_TEXTURE_SWIZZLE_YUYV_CSC1,
    SCE_GXM_TEXTURE_FORMAT_YVYU422_CSC1 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV422 | SCE_GXM_TEXTURE_SWIZZLE_YVYU_CSC1,
    SCE_GXM_TEXTURE_FORMAT_UYVY422_CSC1 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV422 | SCE_GXM_TEXTURE_SWIZZLE_UYVY_CSC1,
    SCE_GXM_TEXTURE_FORMAT_VYUY422_CSC1 = SCE_GXM_TEXTURE_BASE_FORMAT_YUV422 | SCE_GXM_TEXTURE_SWIZZLE_VYUY_CSC1,
    SCE_GXM_TEXTURE_FORMAT_P4_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_P4 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_P4_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_P4 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_P4_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_P4 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_P4_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_P4 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_P4_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_P4 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_P4_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_P4 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_P4_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_P4 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_P4_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_P4 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_P8_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_P8 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_P8_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_P8 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_P8_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_P8 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_P8_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_P8 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_P8_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_P8 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_P8_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_P8 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_P8_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_P8 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_P8_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_P8 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_U8U8U8_BGR = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE3_BGR,
    SCE_GXM_TEXTURE_FORMAT_U8U8U8_RGB = SCE_GXM_TEXTURE_BASE_FORMAT_U8U8U8 | SCE_GXM_TEXTURE_SWIZZLE3_RGB,
    SCE_GXM_TEXTURE_FORMAT_S8S8S8_BGR = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE3_BGR,
    SCE_GXM_TEXTURE_FORMAT_S8S8S8_RGB = SCE_GXM_TEXTURE_BASE_FORMAT_S8S8S8 | SCE_GXM_TEXTURE_SWIZZLE3_RGB,
    SCE_GXM_TEXTURE_FORMAT_U2F10F10F10_ABGR = SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 | SCE_GXM_TEXTURE_SWIZZLE4_ABGR,
    SCE_GXM_TEXTURE_FORMAT_U2F10F10F10_ARGB = SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 | SCE_GXM_TEXTURE_SWIZZLE4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_F10F10F10U2_RGBA = SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 | SCE_GXM_TEXTURE_SWIZZLE4_RGBA,
    SCE_GXM_TEXTURE_FORMAT_F10F10F10U2_BGRA = SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 | SCE_GXM_TEXTURE_SWIZZLE4_BGRA,
    SCE_GXM_TEXTURE_FORMAT_X2F10F10F10_1BGR = SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 | SCE_GXM_TEXTURE_SWIZZLE4_1BGR,
    SCE_GXM_TEXTURE_FORMAT_X2F10F10F10_1RGB = SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 | SCE_GXM_TEXTURE_SWIZZLE4_1RGB,
    SCE_GXM_TEXTURE_FORMAT_F10F10F10X2_RGB1 = SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 | SCE_GXM_TEXTURE_SWIZZLE4_RGB1,
    SCE_GXM_TEXTURE_FORMAT_F10F10F10X2_BGR1 = SCE_GXM_TEXTURE_BASE_FORMAT_U2F10F10F10 | SCE_GXM_TEXTURE_SWIZZLE4_BGR1,
    SCE_GXM_TEXTURE_FORMAT_L8 = SCE_GXM_TEXTURE_FORMAT_U8_1RRR,
    SCE_GXM_TEXTURE_FORMAT_A8 = SCE_GXM_TEXTURE_FORMAT_U8_R000,
    SCE_GXM_TEXTURE_FORMAT_R8 = SCE_GXM_TEXTURE_FORMAT_U8_000R,
    SCE_GXM_TEXTURE_FORMAT_A4R4G4B4 = SCE_GXM_TEXTURE_FORMAT_U4U4U4U4_ARGB,
    SCE_GXM_TEXTURE_FORMAT_A1R5G5B5 = SCE_GXM_TEXTURE_FORMAT_U1U5U5U5_ARGB,
    SCE_GXM_TEXTURE_FORMAT_R5G6B5 = SCE_GXM_TEXTURE_FORMAT_U5U6U5_RGB,
    SCE_GXM_TEXTURE_FORMAT_A8L8 = SCE_GXM_TEXTURE_FORMAT_U8U8_GRRR,
    SCE_GXM_TEXTURE_FORMAT_L8A8 = SCE_GXM_TEXTURE_FORMAT_U8U8_RGGG,
    SCE_GXM_TEXTURE_FORMAT_G8R8 = SCE_GXM_TEXTURE_FORMAT_U8U8_00GR,
    SCE_GXM_TEXTURE_FORMAT_L16 = SCE_GXM_TEXTURE_FORMAT_U16_1RRR,
    SCE_GXM_TEXTURE_FORMAT_A16 = SCE_GXM_TEXTURE_FORMAT_U16_R000,
    SCE_GXM_TEXTURE_FORMAT_R16 = SCE_GXM_TEXTURE_FORMAT_U16_000R,
    SCE_GXM_TEXTURE_FORMAT_D16 = SCE_GXM_TEXTURE_FORMAT_U16_R,
    SCE_GXM_TEXTURE_FORMAT_LF16 = SCE_GXM_TEXTURE_FORMAT_F16_1RRR,
    SCE_GXM_TEXTURE_FORMAT_AF16 = SCE_GXM_TEXTURE_FORMAT_F16_R000,
    SCE_GXM_TEXTURE_FORMAT_RF16 = SCE_GXM_TEXTURE_FORMAT_F16_000R,
    SCE_GXM_TEXTURE_FORMAT_A8R8G8B8 = SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_ARGB,
    SCE_GXM_TEXTURE_FORMAT_A8B8G8R8 = SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_ABGR,
    SCE_GXM_TEXTURE_FORMAT_AF16LF16 = SCE_GXM_TEXTURE_FORMAT_F16F16_GRRR,
    SCE_GXM_TEXTURE_FORMAT_LF16AF16 = SCE_GXM_TEXTURE_FORMAT_F16F16_RGGG,
    SCE_GXM_TEXTURE_FORMAT_GF16RF16 = SCE_GXM_TEXTURE_FORMAT_F16F16_00GR,
    SCE_GXM_TEXTURE_FORMAT_LF32M = SCE_GXM_TEXTURE_FORMAT_F32M_1RRR,
    SCE_GXM_TEXTURE_FORMAT_AF32M = SCE_GXM_TEXTURE_FORMAT_F32M_R000,
    SCE_GXM_TEXTURE_FORMAT_RF32M = SCE_GXM_TEXTURE_FORMAT_F32M_000R,
    SCE_GXM_TEXTURE_FORMAT_DF32M = SCE_GXM_TEXTURE_FORMAT_F32M_R,
    SCE_GXM_TEXTURE_FORMAT_VYUY = SCE_GXM_TEXTURE_FORMAT_VYUY422_CSC0,
    SCE_GXM_TEXTURE_FORMAT_YVYU = SCE_GXM_TEXTURE_FORMAT_YVYU422_CSC0,
    SCE_GXM_TEXTURE_FORMAT_UBC1 = SCE_GXM_TEXTURE_FORMAT_UBC1_ABGR,
    SCE_GXM_TEXTURE_FORMAT_UBC2 = SCE_GXM_TEXTURE_FORMAT_UBC2_ABGR,
    SCE_GXM_TEXTURE_FORMAT_UBC3 = SCE_GXM_TEXTURE_FORMAT_UBC3_ABGR,
    SCE_GXM_TEXTURE_FORMAT_PVRT2BPP = SCE_GXM_TEXTURE_FORMAT_PVRT2BPP_ABGR,
    SCE_GXM_TEXTURE_FORMAT_PVRT4BPP = SCE_GXM_TEXTURE_FORMAT_PVRT4BPP_ABGR,
    SCE_GXM_TEXTURE_FORMAT_PVRTII2BPP = SCE_GXM_TEXTURE_FORMAT_PVRTII2BPP_ABGR,
    SCE_GXM_TEXTURE_FORMAT_PVRTII4BPP = SCE_GXM_TEXTURE_FORMAT_PVRTII4BPP_ABGR
};

struct SceGxmTexture
{
    // https://psp2sdk.github.io/structSceGxmTexture.html
    //uint32_t controlWords[4];
    SceGxmTextureFormat format;
    uint32_t width;
    uint32_t height;
    Ptr<const void> data;
};

static_assert(sizeof(SceGxmTexture) == 16, "Incorrect size.");

enum ColorSurfaceEmitWord : uint32_t
{
    CSEM_WIDTH,
    CSEM_HEIGHT,
    CSEM_STRIDE_IN_PIXELS,
    CSEM_DATA,
};

struct SceGxmColorSurface
{
    // https://psp2sdk.github.io/structSceGxmColorSurface.html
    uint32_t pbeSidebandWord;
    uint32_t pbeEmitWords[6];
    uint32_t outputRegisterSize;
    SceGxmTexture backgroundTex;
};

enum SceGxmColorSurfaceScaleMode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_COLOR_SURFACE_SCALE_NONE,
    SCE_GXM_COLOR_SURFACE_SCALE_MSAA_DOWNSCALE
};

enum SceGxmColorSurfaceType
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_COLOR_SURFACE_LINEAR = 0x00000000,
    SCE_GXM_COLOR_SURFACE_TILED = 0x04000000,
    SCE_GXM_COLOR_SURFACE_SWIZZLED = 0x08000000
};

struct SceGxmContextParams
{
    // https://psp2sdk.github.io/structSceGxmContextParams.html
    Ptr<void> hostMem;
    uint32_t hostMemSize;
    Ptr<void> vdmRingBufferMem;
    uint32_t vdmRingBufferMemSize;
    Ptr<void> vertexRingBufferMem;
    uint32_t vertexRingBufferMemSize;
    Ptr<void> fragmentRingBufferMem;
    uint32_t fragmentRingBufferMemSize;
    Ptr<void> fragmentUsseRingBufferMem;
    uint32_t fragmentUsseRingBufferMemSize;
    uint32_t fragmentUsseRingBufferOffset;
};

struct SceGxmVertexProgram;

struct SceGxmContext
{
    // This is an opaque type.
    SceGxmContextParams params;
    SDL_GLContext gl = nullptr;
    size_t fragment_ring_buffer_used = 0;
    size_t vertex_ring_buffer_used = 0;
    SceGxmColorSurface color_surface;
    const SceGxmVertexProgram *vertex_program = nullptr;
    std::array<const void *, 4> stream_data; // TODO Should this be in the vertex program?
    GLuint index_buffer = 0;
};

enum SceGxmDepthStencilFormat
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_DEPTH_STENCIL_FORMAT_DF32 = 0x00044000,
    SCE_GXM_DEPTH_STENCIL_FORMAT_S8 = 0x00022000,
    SCE_GXM_DEPTH_STENCIL_FORMAT_DF32_S8 = 0x00066000,
    SCE_GXM_DEPTH_STENCIL_FORMAT_S8D24 = 0x01266000,
    SCE_GXM_DEPTH_STENCIL_FORMAT_D16 = 0x02444000
};

struct SceGxmDepthStencilSurface
{
    // https://psp2sdk.github.io/structSceGxmDepthStencilSurface.html
    uint32_t zlsControl;
    Ptr<void> depthData;
    Ptr<void> stencilData;
    float backgroundDepth;
    uint32_t backgroundControl;
};

enum SceGxmDepthStencilSurfaceType
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_DEPTH_STENCIL_SURFACE_LINEAR = 0x00000000,
    SCE_GXM_DEPTH_STENCIL_SURFACE_TILED = 0x00011000
};

struct SceGxmFragmentProgram
{
    // TODO This is an opaque type.
    GLuint program = 0;
};

enum SceGxmIndexFormat
{
    SCE_GXM_INDEX_FORMAT_U16 = 0x00000000,
    SCE_GXM_INDEX_FORMAT_U32 = 0x01000000
};

enum SceGxmMultisampleMode
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_MULTISAMPLE_NONE,
    SCE_GXM_MULTISAMPLE_2X,
    SCE_GXM_MULTISAMPLE_4X
};

struct SceGxmNotification
{
    // https://psp2sdk.github.io/structSceGxmNotification.html
    Ptr<volatile uint32_t> address;
    uint32_t value;
};

enum SceGxmOutputRegisterFormat
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_OUTPUT_REGISTER_FORMAT_DECLARED,
    SCE_GXM_OUTPUT_REGISTER_FORMAT_UCHAR4,
    SCE_GXM_OUTPUT_REGISTER_FORMAT_CHAR4,
    SCE_GXM_OUTPUT_REGISTER_FORMAT_USHORT2,
    SCE_GXM_OUTPUT_REGISTER_FORMAT_SHORT2,
    SCE_GXM_OUTPUT_REGISTER_FORMAT_HALF4,
    SCE_GXM_OUTPUT_REGISTER_FORMAT_HALF2,
    SCE_GXM_OUTPUT_REGISTER_FORMAT_FLOAT2,
    SCE_GXM_OUTPUT_REGISTER_FORMAT_FLOAT
};

enum SceGxmOutputRegisterSize
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_OUTPUT_REGISTER_SIZE_32BIT,
    SCE_GXM_OUTPUT_REGISTER_SIZE_64BIT
};

enum SceGxmParameterCategory : uint8_t
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_PARAMETER_CATEGORY_ATTRIBUTE,
    SCE_GXM_PARAMETER_CATEGORY_UNIFORM,
    SCE_GXM_PARAMETER_CATEGORY_SAMPLER,
    SCE_GXM_PARAMETER_CATEGORY_AUXILIARY_SURFACE,
    SCE_GXM_PARAMETER_CATEGORY_UNIFORM_BUFFER
};

enum SceGxmPrimitiveType
{
    // https://psp2sdk.github.io/gxm_8h.html
    SCE_GXM_PRIMITIVE_TRIANGLES = 0x00000000,
    SCE_GXM_PRIMITIVE_LINES = 0x04000000,
    SCE_GXM_PRIMITIVE_POINTS = 0x08000000,
    SCE_GXM_PRIMITIVE_TRIANGLE_STRIP = 0x0c000000,
    SCE_GXM_PRIMITIVE_TRIANGLE_FAN = 0x10000000,
    SCE_GXM_PRIMITIVE_TRIANGLE_EDGES = 0x14000000
};

struct SceGxmProgram
{
    char magic[4];
    char maybe_version[2];
    char maybe_padding[2];
    uint32_t size;
    uint8_t unknown1[8];
    uint16_t maybe_type;
    uint16_t unknown2[7];
    uint32_t parameter_count;
    uint32_t parameters_offset; // Number of bytes from the start of this field to the first parameter.
};

struct SceGxmProgramParameter
{
    int32_t name_offset; // Number of bytes from the start of this structure to the name string.
    SceGxmParameterCategory category;
    uint8_t container_index : 4;
    uint8_t component_count : 4;
    uint8_t unknown1[2];
    uint8_t array_size;
    uint8_t unknown2[3];
    uint8_t resource_index;
    uint8_t unknown3[3];
};

static_assert(sizeof(SceGxmProgramParameter) == 16, "Incorrect structure layout.");

struct SceGxmRegisteredProgram
{
    // TODO This is an opaque type.
    Ptr<const SceGxmProgram> program;
};

struct SceGxmRenderTarget
{
};

struct SceGxmRenderTargetParams
{
    // Napier tutorial 3.
    // https://psp2sdk.github.io/structSceGxmRenderTargetParams.html
    uint32_t flags = 0;
    uint16_t width = 0;
    uint16_t height = 0;
    uint16_t scenesPerFrame = 1;
    uint16_t multisampleMode = 0;
    uint32_t multisampleLocations = 0;
    SceUID driverMemBlock = SCE_UID_INVALID_UID;
};

typedef std::map<Ptr<const SceGxmProgram>, GLuint> ProgramToVertexShader;

struct SceGxmShaderPatcher
{
    // TODO This is an opaque struct.
    ProgramToVertexShader vertex_shaders;
};

typedef Ptr<SceGxmRegisteredProgram> SceGxmShaderPatcherId;

// https://psp2sdk.github.io/gxm_8h.html
typedef Ptr<void> SceGxmShaderPatcherHostAllocCallback(Ptr<void> userData, uint32_t size);
typedef void SceGxmShaderPatcherHostFreeCallback(Ptr<void> userData, Ptr<void> mem);
typedef Ptr<void> SceGxmShaderPatcherBufferAllocCallback(Ptr<void> userData, uint32_t size);
typedef void SceGxmShaderPatcherBufferFreeCallback(Ptr<void> userData, Ptr<void> mem);
typedef Ptr<void> SceGxmShaderPatcherUsseAllocCallback(Ptr<void> userData, uint32_t size, Ptr<uint32_t> usseOffset);
typedef void SceGxmShaderPatcherUsseFreeCallback(Ptr<void> userData, Ptr<void> mem);

struct SceGxmShaderPatcherParams
{
    // https://psp2sdk.github.io/structSceGxmShaderPatcherParams.html
    Ptr<void> userData;
    Ptr<SceGxmShaderPatcherHostAllocCallback> hostAllocCallback;
    Ptr<SceGxmShaderPatcherHostFreeCallback> hostFreeCallback;
    Ptr<SceGxmShaderPatcherBufferAllocCallback> bufferAllocCallback;
    Ptr<SceGxmShaderPatcherBufferFreeCallback> bufferFreeCallback;
    Ptr<void> bufferMem;
    uint32_t bufferMemSize;
    Ptr<SceGxmShaderPatcherUsseAllocCallback> vertexUsseAllocCallback;
    Ptr<SceGxmShaderPatcherUsseFreeCallback> vertexUsseFreeCallback;
    Ptr<void> vertexUsseMem;
    uint32_t vertexUsseMemSize;
    uint32_t vertexUsseOffset;
    Ptr<SceGxmShaderPatcherUsseAllocCallback> fragmentUsseAllocCallback;
    Ptr<SceGxmShaderPatcherUsseFreeCallback> fragmentUsseFreeCallback;
    Ptr<void> fragmentUsseMem;
    uint32_t fragmentUsseMemSize;
    uint32_t fragmentUsseOffset;
};

struct SceGxmSyncObject
{
};

struct SceGxmValidRegion
{
    // https://psp2sdk.github.io/structSceGxmValidRegion.html
    uint32_t xMin;
    uint32_t yMin;
    uint32_t xMax;
    uint32_t yMax;
};

struct SceGxmVertexAttribute
{
    // https://psp2sdk.github.io/structSceGxmVertexAttribute.html
    uint16_t streamIndex;
    uint16_t offset;
    SceGxmAttributeFormat format;
    uint8_t componentCount;
    uint16_t regIndex; // Returned from sceGxmProgramParameterGetResourceIndex().
};

static_assert(sizeof(SceGxmVertexAttribute) == 8, "Structure has been incorrectly packed.");

struct SceGxmVertexStream
{
    // https://psp2sdk.github.io/structSceGxmVertexStream.html
    uint16_t stride;
    uint16_t indexSource;
};

struct SceGxmVertexProgram
{
    // TODO I think this is an opaque type.
    GLuint shader = 0;
    std::array<GLuint, 4> stream_vbos;
    GLuint vao = 0;
};

// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash
static uint64_t fnv1a(const void *data, size_t size)
{
    const uint8_t *const begin = static_cast<const uint8_t *>(data);
    const uint8_t *const end = begin + size;
    uint64_t result = 0xcbf29ce484222325;
    
    for (const uint8_t *p = begin; p != end; ++p)
    {
        result ^= *p;
        result *= 0x100000001b3;
    }
    
    return result;
}

static void check()
{
    for (GLenum error = glGetError(); error != GL_NO_ERROR; error = glGetError())
    {
        std::cerr << "OpenGL error 0x" << std::hex << error << std::dec << std::endl;
        assert(false);
    }
}

static GLuint create_and_compile_shader(GLenum type, const GLchar *source)
{
    GLuint shader = glCreateShader(type);
    if (shader == 0)
    {
        return 0;
    }
    
    const GLint length = static_cast<GLint>(strlen(source));
    glShaderSource(shader, 1, &source, &length);
    check();
    
    glCompileShader(shader);
    check();
    
    GLint log_length = 0;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &log_length);
    check();
    
    if (log_length > 0)
    {
        std::vector<GLchar> log;
        log.resize(log_length);
        glGetShaderInfoLog(shader, log_length, nullptr, &log.front());
        check();
        
        std::cerr << &log.front() << std::endl;
    }
    
    GLint is_compiled = GL_FALSE;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &is_compiled);
    check();
    assert(is_compiled != GL_FALSE);
    if (is_compiled == GL_FALSE)
    {
        glDeleteShader(shader);
        check();
        shader = 0;
        
        return 0;
    }
    
    return shader;
}

static GLuint create_and_compile_shader(GLenum type, const SceGxmProgram *program)
{
    const uint64_t hash = fnv1a(program, program->size);
    std::ostringstream path;
    path << "shaders/" << hash << ".glsl";
    
    std::ifstream is(path.str());
    if (is.fail())
    {
        std::cerr << "Couldn't open '" << path.str() << "' for reading." << std::endl;
        return TODO_FILE_NOT_FOUND;
    }
    
    is.seekg(0, std::ios::end);
    const size_t size = is.tellg();
    is.seekg(0);
    
    std::string source(size, ' ');
    is.read(&source[0], size);
    
    return create_and_compile_shader(type, source.c_str());
}

static GLenum attribute_format_to_gl_type(SceGxmAttributeFormat format)
{
    switch (format) {
        case SCE_GXM_ATTRIBUTE_FORMAT_U8:
        case SCE_GXM_ATTRIBUTE_FORMAT_U8N:
            return GL_UNSIGNED_BYTE;
        case SCE_GXM_ATTRIBUTE_FORMAT_S8:
        case SCE_GXM_ATTRIBUTE_FORMAT_S8N:
            return GL_BYTE;
        case SCE_GXM_ATTRIBUTE_FORMAT_U16:
        case SCE_GXM_ATTRIBUTE_FORMAT_U16N:
            return GL_UNSIGNED_SHORT;
        case SCE_GXM_ATTRIBUTE_FORMAT_S16:
        case SCE_GXM_ATTRIBUTE_FORMAT_S16N:
            return GL_SHORT;
        case SCE_GXM_ATTRIBUTE_FORMAT_F16:
            return GL_HALF_FLOAT;
        case SCE_GXM_ATTRIBUTE_FORMAT_F32:
            return GL_FLOAT;
            
        default:
            assert(!"Unhandled format.");
            return GL_UNSIGNED_BYTE;
    }
}

static bool attribute_format_normalised(SceGxmAttributeFormat format)
{
    switch (format) {
        case SCE_GXM_ATTRIBUTE_FORMAT_U8N:
        case SCE_GXM_ATTRIBUTE_FORMAT_S8N:
        case SCE_GXM_ATTRIBUTE_FORMAT_U16N:
        case SCE_GXM_ATTRIBUTE_FORMAT_S16N:
            return true;
        default:
            return false;
    }
}

static GLsizei compute_vertex_count(SceGxmIndexFormat type, const void *data, GLsizei index_count)
{
    if (index_count == 0)
    {
        return 0;
    }
    else if (data == nullptr)
    {
        return index_count;
    }
    else if (type == SCE_GXM_INDEX_FORMAT_U16)
    {
        const uint16_t *const begin = static_cast<const uint16_t *>(data);
        const uint16_t *const end = begin + index_count;
        return *std::max_element(begin, end) + 1;
    }
    else
    {
        const uint32_t *const begin = static_cast<const uint32_t *>(data);
        const uint32_t *const end = begin + index_count;
        return *std::max_element(begin, end) + 1;
    }
}

static void bind_attribute_locations(GLuint gl_program, const SceGxmProgram *program)
{
    const SceGxmProgramParameter *const parameters = reinterpret_cast<const SceGxmProgramParameter *>(reinterpret_cast<const uint8_t *>(&program->parameters_offset) + program->parameters_offset);
    for (int i = 0; i < program->parameter_count; ++i)
    {
        const SceGxmProgramParameter *const parameter = &parameters[i];
        if (parameter->category == SCE_GXM_PARAMETER_CATEGORY_ATTRIBUTE)
        {
            const uint8_t *const parameter_bytes = reinterpret_cast<const uint8_t *>(parameter);
            const char *const parameter_name = reinterpret_cast<const char *>(parameter_bytes + parameter->name_offset);
            
            glBindAttribLocation(gl_program, parameter->resource_index, parameter_name);
            check();
        }
    }
}

IMP_SIG(sceGxmBeginScene)
{
    // https://psp2sdk.github.io/gxm_8h.html
    struct Stack
    {
        Ptr<SceGxmSyncObject> vertexSyncObject;
        Ptr<SceGxmSyncObject> fragmentSyncObject;
        Ptr<const SceGxmColorSurface> colorSurface;
        Ptr<const SceGxmDepthStencilSurface> depthStencil;
    };
    
    const MemState *const mem = &emu->mem;
    const Stack *const stack = sp.cast<const Stack>().get(mem);
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(mem);
    const uint32_t flags = r1;
    const SceGxmRenderTarget *const renderTarget = Ptr<const SceGxmRenderTarget>(r2).get(mem);
    const SceGxmValidRegion *const validRegion = Ptr<const SceGxmValidRegion>(r3).get(mem);
    assert(stack != nullptr);
    assert(context != nullptr);
    assert(flags == 0);
    assert(renderTarget != nullptr);
    assert(validRegion == nullptr);
    assert(!stack->vertexSyncObject);
    assert(stack->fragmentSyncObject);
    assert(stack->colorSurface);
    assert(stack->depthStencil);
    
    // TODO This may not be right.
    context->fragment_ring_buffer_used = 0;
    context->vertex_ring_buffer_used = 0;
    context->color_surface = *stack->colorSurface.get(mem);
    
    // TODO This is just for debugging.
    glClear(GL_COLOR_BUFFER_BIT);
    check();
    
    return SCE_OK;
}

IMP_SIG(sceGxmColorSurfaceInit)
{
    // https://psp2sdk.github.io/gxm_8h.html
    struct Stack
    {
        SceGxmOutputRegisterSize outputRegisterSize;
        uint32_t width;
        uint32_t height;
        uint32_t strideInPixels;
        Ptr<void> data;
    };
    
    SceGxmColorSurface *const surface = Ptr<SceGxmColorSurface>(r0).get(&emu->mem);
    SceGxmColorFormat colorFormat = static_cast<SceGxmColorFormat>(r1);
    SceGxmColorSurfaceType surfaceType = static_cast<SceGxmColorSurfaceType>(r2);
    SceGxmColorSurfaceScaleMode scaleMode = static_cast<SceGxmColorSurfaceScaleMode>(r3);
    const Stack *const stack = sp.cast<const Stack>().get(&emu->mem);
    void *const data = stack->data.get(&emu->mem);
    assert(surface != nullptr);
    assert(colorFormat == SCE_GXM_COLOR_FORMAT_A8B8G8R8);
    assert(surfaceType == SCE_GXM_COLOR_SURFACE_LINEAR);
    assert(scaleMode == SCE_GXM_COLOR_SURFACE_SCALE_NONE);
    assert(stack->outputRegisterSize == SCE_GXM_OUTPUT_REGISTER_SIZE_32BIT);
    assert(stack->width > 0);
    assert(stack->height > 0);
    assert(stack->strideInPixels > 0);
    assert(data != nullptr);
    
    // TODO Initialise.
    memset(surface, 0, sizeof(*surface));
    surface->pbeEmitWords[CSEM_WIDTH] = stack->width;
    surface->pbeEmitWords[CSEM_HEIGHT] = stack->height;
    surface->pbeEmitWords[CSEM_STRIDE_IN_PIXELS] = stack->strideInPixels;
    surface->pbeEmitWords[CSEM_DATA] = stack->data.address();
    surface->outputRegisterSize = stack->outputRegisterSize;
    
    return SCE_OK;
}

IMP_SIG(sceGxmCreateContext)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const SceGxmContextParams *const params = Ptr<const SceGxmContextParams>(r0).get(&emu->mem);
    Ptr<SceGxmContext> *const context = Ptr<Ptr<SceGxmContext>>(r1).get(&emu->mem);
    assert(params != nullptr);
    assert(context != nullptr);
    
    *context = alloc<SceGxmContext>(&emu->mem, __FUNCTION__);
    if (!*context)
    {
        return OUT_OF_MEMORY;
    }
    
    SceGxmContext *const ctx = context->get(&emu->mem);
    ctx->params = *params;
    
    assert(SDL_GL_GetCurrentContext() == nullptr);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    ctx->gl = SDL_GL_CreateContext(emu->window.get());
    assert(ctx->gl != nullptr);
    
    std::cout << "GL_VERSION = " << glGetString(GL_VERSION) << std::endl;
    check();
    
    std::cout << "GL_SHADING_LANGUAGE_VERSION = " << glGetString(GL_SHADING_LANGUAGE_VERSION) << std::endl;
    check();
    
    glewExperimental = GL_TRUE;
    if (glewInit() != GLEW_OK)
    {
        return TODO_GLEW_INIT_FAILED;
    }
    
    // Clear any errors caused by GLEW.
    while (glGetError() != GL_NO_ERROR)
    {
    }
    check();
    
    // TODO This is just for debugging.
    glClearColor(0.0625f, 0.125f, 0.25f, 0);
    check();
    
    glGenBuffers(1, &ctx->index_buffer);
    check();
    if (ctx->index_buffer == 0)
    {
        // TODO Free vertexProgram.
        
        return OUT_OF_MEMORY;
    }
    
    return SCE_OK;
}

IMP_SIG(sceGxmCreateRenderTarget)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const SceGxmRenderTargetParams *const params = Ptr<const SceGxmRenderTargetParams>(r0).get(&emu->mem);
    Ptr<SceGxmRenderTarget> *const renderTarget = Ptr<Ptr<SceGxmRenderTarget>>(r1).get(&emu->mem);
    assert(params != nullptr);
    assert(renderTarget != nullptr);
    
    *renderTarget = alloc<SceGxmRenderTarget>(&emu->mem, __FUNCTION__);
    if (!*renderTarget)
    {
        return OUT_OF_MEMORY;
    }
    
    return SCE_OK;
}

IMP_SIG(sceGxmDepthStencilSurfaceInit)
{
    // https://psp2sdk.github.io/gxm_8h.html
    struct Stack
    {
        Ptr<void> depthData;
        Ptr<void> stencilData;
    };
    
    SceGxmDepthStencilSurface *const surface = Ptr<SceGxmDepthStencilSurface>(r0).get(&emu->mem);
    const SceGxmDepthStencilFormat depthStencilFormat = static_cast<SceGxmDepthStencilFormat>(r1);
    const SceGxmDepthStencilSurfaceType surfaceType = static_cast<SceGxmDepthStencilSurfaceType>(r2);
    const uint32_t strideInSamples = r3;
    const Stack *const stack = sp.cast<const Stack>().get(&emu->mem);
    void *const depthData = stack->depthData.get(&emu->mem);
    void *const stencilData = stack->stencilData.get(&emu->mem);
    assert(surface != nullptr);
    assert(depthStencilFormat == SCE_GXM_DEPTH_STENCIL_FORMAT_S8D24);
    assert(surfaceType == SCE_GXM_DEPTH_STENCIL_SURFACE_TILED);
    assert(strideInSamples > 0);
    assert(depthData != nullptr);
    assert(stencilData == nullptr);
    
    // TODO What to do here?
    memset(surface, 0, sizeof(*surface));
    surface->depthData = stack->depthData;
    surface->stencilData = stack->stencilData;
    
    return SCE_OK;
}

IMP_SIG(sceGxmDestroyContext)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(mem);
    assert(context != nullptr);
    
    glDeleteBuffers(1, &context->index_buffer);
    check();
    context->index_buffer = 0;
    
    assert(context->gl != nullptr);
    SDL_GL_DeleteContext(context->gl);
    context->gl = nullptr;
    
    // TODO Free the context.
    
    return SCE_OK;
}

IMP_SIG(sceGxmDestroyRenderTarget)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    SceGxmRenderTarget *const renderTarget = Ptr<SceGxmRenderTarget>(r0).get(mem);
    assert(renderTarget != nullptr);
    
    // TODO Free the render target.
    
    return SCE_OK;
}

IMP_SIG(sceGxmDisplayQueueAddEntry)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    SceGxmSyncObject *const oldBuffer = Ptr<SceGxmSyncObject>(r0).get(mem);
    SceGxmSyncObject *const newBuffer = Ptr<SceGxmSyncObject>(r1).get(mem);
    const Ptr<const void> callbackData = Ptr<const void>(r2);
    assert(oldBuffer != nullptr);
    assert(newBuffer != nullptr);
    assert(callbackData);
    
    Address lr = 0;
    uc_err err = uc_reg_read(thread->uc, UC_ARM_REG_LR, &lr);
    assert(err == UC_ERR_OK);
    
    const Address callback_data_address = callbackData.address();
    const Address callback_lr = emu->stop.entry_point.address();
    
    err = uc_emu_stop(thread->uc);
    assert(err == UC_ERR_OK);
    
    Trampoline call_callback;
    call_callback.name = "Call callback";
    call_callback.entry_point = emu->gxm.params.displayQueueCallback.cast<const void>();
    call_callback.prefix = [callback_data_address, callback_lr, thread]()
    {
        int regs[] = { UC_ARM_REG_R0, UC_ARM_REG_LR };
        const void *vals[] = { &callback_data_address, &callback_lr };
        
        const uc_err err = uc_reg_write_batch(thread->uc, regs, const_cast<void *const *>(vals), 2);
        assert(err == UC_ERR_OK);
    };
    
    Trampoline resume;
    resume.name = "Resume after callback";
    resume.entry_point = Ptr<const void>(lr);
    resume.prefix = [thread]()
    {
        // TODO It's a little odd to use ImportResult for this.
        const ImportResult return_ok(SCE_OK);
        return_ok.apply(thread->uc);
    };
    
    add_trampoline(thread, call_callback);
    add_trampoline(thread, resume);
    
    return ImportResult();
}

IMP_SIG(sceGxmDisplayQueueFinish)
{
    // https://psp2sdk.github.io/gxm_8h.html
    return SCE_OK;
}

IMP_SIG(sceGxmDraw)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(mem);
    const SceGxmPrimitiveType primType = static_cast<SceGxmPrimitiveType>(r1);
    const SceGxmIndexFormat indexType = static_cast<SceGxmIndexFormat>(r2);
    const void *const indexData = Ptr<const void>(r3).get(mem);
    const uint32_t indexCount = *sp.cast<uint32_t>().get(mem);
    assert(context != nullptr);
    assert((primType == SCE_GXM_PRIMITIVE_TRIANGLES) || (primType == SCE_GXM_PRIMITIVE_TRIANGLE_STRIP));
    assert(indexType == SCE_GXM_INDEX_FORMAT_U16);
    assert(indexData != nullptr);
    assert(indexCount > 0);
    
    const GLuint attribute_index = 0; // TODO Get attribute index from stream.
    GLint stride = 0;
    glGetVertexAttribiv(attribute_index, GL_VERTEX_ATTRIB_ARRAY_STRIDE, &stride);
    check();
    
    const GLuint stream_index = 0; // TODO Do for all streams.
    glBindBuffer(GL_ARRAY_BUFFER, context->vertex_program->stream_vbos[stream_index]);
    check();
    
    const GLsizei vertex_count = compute_vertex_count(indexType, indexData, indexCount);
    const GLsizei size = stride * vertex_count;
    glBufferData(GL_ARRAY_BUFFER, size, context->stream_data[stream_index], GL_STREAM_DRAW);
    check();
    
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    check();
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, context->index_buffer);
    check();
    
    const GLsizei index_size = indexType == SCE_GXM_INDEX_FORMAT_U16 ? 2 : 4;
    const GLsizei indices_size = indexCount * index_size;
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices_size, indexData, GL_STREAM_DRAW);
    check();
    
    const GLenum mode = primType == SCE_GXM_PRIMITIVE_TRIANGLES ? GL_TRIANGLES : GL_TRIANGLE_STRIP;
    const GLenum type = indexType == SCE_GXM_INDEX_FORMAT_U16 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT;
    glDrawElements(mode, indexCount, type, nullptr);
    check();
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    check();
    
    return SCE_OK;
}

IMP_SIG(sceGxmEndScene)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(mem);
    const SceGxmNotification *const vertexNotification = Ptr<const SceGxmNotification>(r1).get(mem);
    const SceGxmNotification *const fragmentNotification = Ptr<const SceGxmNotification>(r2).get(mem);
    assert(context != nullptr);
    assert(vertexNotification == nullptr);
    assert(fragmentNotification == nullptr);
    
    const GLsizei width = context->color_surface.pbeEmitWords[CSEM_WIDTH];
    const GLsizei height = context->color_surface.pbeEmitWords[CSEM_HEIGHT];
    const GLsizei stride_in_pixels = context->color_surface.pbeEmitWords[CSEM_STRIDE_IN_PIXELS];
    const Address data = context->color_surface.pbeEmitWords[CSEM_DATA];
    void *const pixels = Ptr<void>(data).get(mem);
    glPixelStorei(GL_PACK_ROW_LENGTH, stride_in_pixels);
    check();
    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
    check();
    
    return SCE_OK;
}

IMP_SIG(sceGxmFinish)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(mem);
    assert(context != nullptr);
    
    return ImportResult();
}

IMP_SIG(sceGxmInitialize)
{
    const SceGxmInitializeParams *const params = Ptr<const SceGxmInitializeParams>(r0).get(&emu->mem);
    assert(params != nullptr);
    
    emu->gxm.params = *params;
    
    return SCE_OK;
}

IMP_SIG(sceGxmMapFragmentUsseMemory)
{
    void *const base = Ptr<void>(r0).get(&emu->mem);
    const uint32_t size = r1;
    uint32_t *const offset = Ptr<uint32_t>(r2).get(&emu->mem);
    assert(base != nullptr);
    assert(size > 0);
    assert(offset != nullptr);
    
    // TODO What should this be?
    *offset = r0;
    
    return SCE_OK;
}

IMP_SIG(sceGxmMapMemory)
{
    const void *const address = Ptr<const void>(r0).get(&emu->mem);
    const size_t size = r1;
    const GxmMemoryAttrib attributes = static_cast<GxmMemoryAttrib>(r2);
    assert(address != nullptr);
    assert(size > 0);
    assert((attributes == SCE_GXM_MEMORY_ATTRIB_READ) || (attributes == SCE_GXM_MEMORY_ATTRIB_RW));
    
    return SCE_OK;
}

IMP_SIG(sceGxmMapVertexUsseMemory)
{
    void *const base = Ptr<void>(r0).get(&emu->mem);
    const uint32_t size = r1;
    uint32_t *const offset = Ptr<uint32_t>(r2).get(&emu->mem);
    assert(base != nullptr);
    assert(size > 0);
    assert(offset != nullptr);
    
    // TODO What should this be?
    *offset = r0;
    
    return SCE_OK;
}

IMP_SIG(sceGxmPadHeartbeat)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    const SceGxmColorSurface *const displaySurface = Ptr<const SceGxmColorSurface>(r0).get(mem);
    SceGxmSyncObject *const displaySyncObject = Ptr<SceGxmSyncObject>(r1).get(mem);
    assert(displaySurface != nullptr);
    assert(displaySyncObject != nullptr);
    
    return SCE_OK;
}

IMP_SIG(sceGxmProgramCheck)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const SceGxmProgram *program = Ptr<const SceGxmProgram>(r0).get(&emu->mem);
    assert(program != nullptr);
    
    assert(memcmp(program->magic, "GXP", 4) == 0);
    assert(program->maybe_version[0] == 1);
    assert(program->maybe_version[1] == 4);
    assert(program->maybe_padding[0] == 0);
    assert(program->maybe_padding[1] == 0);
    
    return SCE_OK;
}

IMP_SIG(sceGxmProgramFindParameterByName)
{
    const MemState *const mem = &emu->mem;
    const SceGxmProgram *const program = Ptr<const SceGxmProgram>(r0).get(mem);
    const char *const name = Ptr<const char>(r1).get(mem);
    assert(program != nullptr);
    assert(name != nullptr);
    
    const SceGxmProgramParameter *const parameters = reinterpret_cast<const SceGxmProgramParameter *>(reinterpret_cast<const uint8_t *>(&program->parameters_offset) + program->parameters_offset);
    for (int i = 0; i < program->parameter_count; ++i)
    {
        const SceGxmProgramParameter *const parameter = &parameters[i];
        const uint8_t *const parameter_bytes = reinterpret_cast<const uint8_t *>(parameter);
        const char *const parameter_name = reinterpret_cast<const char *>(parameter_bytes + parameter->name_offset);
        if (strcmp(parameter_name, name) == 0)
        {
            const Address parameter_address = static_cast<Address>(parameter_bytes - &mem->memory[0]);
            return parameter_address;
        }
    }
    
    return Ptr<SceGxmProgramParameter>().address();
}

IMP_SIG(sceGxmProgramParameterGetResourceIndex)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const SceGxmProgramParameter *const parameter = Ptr<const SceGxmProgramParameter>(r0).get(&emu->mem);
    assert(parameter != nullptr);
    
    return parameter->resource_index;
}

IMP_SIG(sceGxmReserveFragmentDefaultUniformBuffer)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(&emu->mem);
    Ptr<void> *const uniformBuffer = Ptr<Ptr<void>>(r1).get(&emu->mem);
    assert(context != nullptr);
    assert(uniformBuffer != nullptr);
    
    const size_t size = 64; // TODO I guess this must be in the fragment program.
    const size_t next_used = context->fragment_ring_buffer_used + size;
    assert(next_used <= context->params.fragmentRingBufferMemSize);
    if (next_used > context->params.fragmentRingBufferMemSize)
    {
        return OUT_OF_MEMORY;
    }
    
    *uniformBuffer = context->params.fragmentRingBufferMem.cast<uint8_t>() + static_cast<int32_t>(context->fragment_ring_buffer_used);
    context->fragment_ring_buffer_used = next_used;
    
    return SCE_OK;
}

IMP_SIG(sceGxmReserveVertexDefaultUniformBuffer)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(&emu->mem);
    Ptr<void> *const uniformBuffer = Ptr<Ptr<void>>(r1).get(&emu->mem);
    assert(context != nullptr);
    assert(uniformBuffer != nullptr);
    
    const size_t size = 64; // TODO I guess this must be in the vertex program.
    const size_t next_used = context->vertex_ring_buffer_used + size;
    assert(next_used <= context->params.vertexRingBufferMemSize);
    if (next_used > context->params.vertexRingBufferMemSize)
    {
        return OUT_OF_MEMORY;
    }
    
    *uniformBuffer = context->params.vertexRingBufferMem.cast<uint8_t>() + static_cast<int32_t>(context->vertex_ring_buffer_used);
    context->vertex_ring_buffer_used = next_used;
    
    return SCE_OK;
}

IMP_SIG(sceGxmSetFragmentProgram)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(&emu->mem);
    const SceGxmFragmentProgram *const fragmentProgram = Ptr<const SceGxmFragmentProgram>(r1).get(&emu->mem);
    assert(context != nullptr);
    assert(fragmentProgram != nullptr);
    
    assert(fragmentProgram->program != 0);
    glUseProgram(fragmentProgram->program);
    check();
    
    return ImportResult();
}

IMP_SIG(sceGxmSetFragmentTexture)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(&emu->mem);
    const uint32_t textureIndex = r1;
    const SceGxmTexture *const texture = Ptr<const SceGxmTexture>(r2).get(&emu->mem);
    assert(context != nullptr);
    assert(textureIndex == 0);
    assert(texture != nullptr);
    
    return SCE_OK;
}

IMP_SIG(sceGxmSetUniformDataF)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const Ptr<void> uniformBuffer(r0);
    const SceGxmProgramParameter *const parameter = Ptr<const SceGxmProgramParameter>(r1).get(&emu->mem);
    const uint32_t componentOffset = r2;
    const uint32_t componentCount = r3;
    const float *const sourceData = sp.cast<Ptr<const float>>().get(&emu->mem)->get(&emu->mem);
    assert(uniformBuffer);
    assert(parameter != nullptr);
    assert(componentOffset == 0);
    assert(componentCount > 0);
    assert(sourceData != nullptr);
    
    const char *const name = reinterpret_cast<const char *>(parameter) + parameter->name_offset;
    
    GLint program = 0;
    glGetIntegerv(GL_CURRENT_PROGRAM, &program);
    check();
    assert(program != 0);
    
    const GLint location = glGetUniformLocation(program, name);
    check();
    assert(location >= 0);
    
    switch (componentCount)
    {
        case 4:
            glUniform4fv(location, 1, sourceData);
            check();
            break;
            
        case 16:
            glUniformMatrix4fv(location, 1, GL_TRUE, sourceData);
            check();
            break;
            
        default:
            assert(!"Unhandled component count.");
            break;
    }
    
    return SCE_OK;
}

IMP_SIG(sceGxmSetVertexProgram)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(&emu->mem);
    const SceGxmVertexProgram *const vertexProgram = Ptr<const SceGxmVertexProgram>(r1).get(&emu->mem);
    assert(context != nullptr);
    assert(vertexProgram != nullptr);
    
    glBindVertexArray(vertexProgram->vao);
    check();
    
    context->vertex_program = vertexProgram;
    
    return SCE_OK;
}

IMP_SIG(sceGxmSetVertexStream)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    SceGxmContext *const context = Ptr<SceGxmContext>(r0).get(mem);
    const uint32_t streamIndex = r1;
    const void *const streamData = Ptr<const void>(r2).get(mem);
    assert(context != nullptr);
    assert(streamIndex == 0);
    assert(streamData != nullptr);
    
    context->stream_data[streamIndex] = streamData;
    
    return SCE_OK;
}

IMP_SIG(sceGxmShaderPatcherCreate)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const SceGxmShaderPatcherParams *const params = Ptr<const SceGxmShaderPatcherParams>(r0).get(&emu->mem);
    Ptr<SceGxmShaderPatcher> *const shaderPatcher = Ptr<Ptr<SceGxmShaderPatcher>>(r1).get(&emu->mem);
    assert(params != nullptr);
    assert(shaderPatcher != nullptr);
    
    *shaderPatcher = alloc<SceGxmShaderPatcher>(&emu->mem, __FUNCTION__);
    assert(*shaderPatcher);
    if (!*shaderPatcher)
    {
        return OUT_OF_MEMORY;
    }
    
    return SCE_OK;
}

IMP_SIG(sceGxmShaderPatcherCreateFragmentProgram)
{
    // https://psp2sdk.github.io/gxm_8h.html
    struct Stack
    {
        Ptr<const SceGxmBlendInfo> blendInfo;
        Ptr<const SceGxmProgram> vertexProgram;
        Ptr<Ptr<SceGxmFragmentProgram>> fragmentProgram;
    };
    
    MemState *const mem = &emu->mem;
    SceGxmShaderPatcher *const shaderPatcher = Ptr<SceGxmShaderPatcher>(r0).get(mem);
    const SceGxmRegisteredProgram *const programId = SceGxmShaderPatcherId(r1).get(mem);
    const SceGxmOutputRegisterFormat outputFormat = static_cast<SceGxmOutputRegisterFormat>(r2);
    const SceGxmMultisampleMode multisampleMode = static_cast<SceGxmMultisampleMode>(r3);
    const Stack *const stack = sp.cast<const Stack>().get(mem);
    const SceGxmBlendInfo *const blendInfo = stack->blendInfo.get(mem);
    Ptr<SceGxmFragmentProgram> *const fragmentProgram = stack->fragmentProgram.get(mem);
    assert(shaderPatcher != nullptr);
    assert(programId != 0);
    assert(outputFormat == SCE_GXM_OUTPUT_REGISTER_FORMAT_UCHAR4);
    assert(multisampleMode == SCE_GXM_MULTISAMPLE_NONE);
    assert((blendInfo == nullptr) || (blendInfo != nullptr));
    assert(stack->vertexProgram);
    assert(fragmentProgram != nullptr);
    
    *fragmentProgram = alloc<SceGxmFragmentProgram>(mem, __FUNCTION__);
    assert(*fragmentProgram);
    if (!*fragmentProgram)
    {
        return OUT_OF_MEMORY;
    }
    
    SceGxmFragmentProgram *const fp = fragmentProgram->get(mem);
    GLuint fragment_shader = create_and_compile_shader(GL_FRAGMENT_SHADER, programId->program.get(mem));
    assert(fragment_shader != 0);
    if (!fragment_shader)
    {
        // TODO Free fragmentProgram.
        
        return TODO_COMPILE_FAILED;
    }
    
    fp->program = glCreateProgram();
    check();
    if (!fp->program)
    {
        glDeleteShader(fragment_shader);
        check();
        fragment_shader = 0;
        
        // TODO Free fragmentProgram.
        
        return TODO_CREATE_PROGRAM_FAILED;
    }
    
    const ProgramToVertexShader::const_iterator vertex_shader = shaderPatcher->vertex_shaders.find(stack->vertexProgram);
    assert(vertex_shader != shaderPatcher->vertex_shaders.end());
    
    glAttachShader(fp->program, vertex_shader->second);
    check();
    glAttachShader(fp->program, fragment_shader);
    check();
    
    bind_attribute_locations(fp->program, stack->vertexProgram.get(mem));
    
    glLinkProgram(fp->program);
    check();
    
    GLint log_length = 0;
    glGetProgramiv(fp->program, GL_INFO_LOG_LENGTH, &log_length);
    check();
    
    if (log_length > 0)
    {
        std::vector<GLchar> log;
        log.resize(log_length);
        glGetProgramInfoLog(fp->program, log_length, nullptr, &log.front());
        check();
        
        std::cerr << &log.front() << std::endl;
    }
    
    GLint is_linked = GL_FALSE;
    glGetProgramiv(fp->program, GL_LINK_STATUS, &is_linked);
    check();
    assert(is_linked != GL_FALSE);
    if (is_linked == GL_FALSE)
    {
        glDeleteProgram(fp->program);
        check();
        fp->program = 0;
        
        // TODO Free fragmentProgram.
        
        return TODO_LINK_PROGRAM_FAILED;
    }
    
    glDetachShader(fp->program, fragment_shader);
    check();
    glDetachShader(fp->program, vertex_shader->second);
    check();
    
    glDeleteShader(fragment_shader);
    check();
    fragment_shader = 0;
    
    return SCE_OK;
}

IMP_SIG(sceGxmShaderPatcherCreateVertexProgram)
{
    // https://psp2sdk.github.io/gxm_8h.html
    struct Stack
    {
        Ptr<const SceGxmVertexStream> streams;
        uint32_t streamCount;
        Ptr<Ptr<SceGxmVertexProgram>> vertexProgram;
    };
    
    MemState *const mem = &emu->mem;
    SceGxmShaderPatcher *const shaderPatcher = Ptr<SceGxmShaderPatcher>(r0).get(mem);
    const SceGxmRegisteredProgram *const programId = SceGxmShaderPatcherId(r1).get(mem);
    const SceGxmVertexAttribute *const attributes = Ptr<const SceGxmVertexAttribute>(r2).get(mem);
    const uint32_t attributeCount = r3;
    const Stack *const stack = sp.cast<const Stack>().get(mem);
    const SceGxmVertexStream *const streams = stack->streams.get(mem);
    Ptr<SceGxmVertexProgram> *const vertexProgram = stack->vertexProgram.get(mem);
    assert(shaderPatcher != nullptr);
    assert(programId != 0);
    assert(attributes != nullptr);
    assert(attributeCount > 0);
    assert(streams != nullptr);
    assert(stack->streamCount > 0);
    assert(vertexProgram != nullptr);
    
    *vertexProgram = alloc<SceGxmVertexProgram>(mem, __FUNCTION__);
    assert(*vertexProgram);
    if (!*vertexProgram)
    {
        return OUT_OF_MEMORY;
    }
    
    SceGxmVertexProgram *const vp = vertexProgram->get(mem);
    vp->shader = create_and_compile_shader(GL_VERTEX_SHADER, programId->program.get(mem));
    assert(vp->shader != 0);
    if (!vp->shader)
    {
        // TODO Free vertexProgram.
        
        return TODO_COMPILE_FAILED;
    }
    
    vp->stream_vbos.fill(0);
    glGenBuffers(static_cast<GLsizei>(vp->stream_vbos.size()), &vp->stream_vbos[0]);
    check();
    if (vp->stream_vbos[0] == 0)
    {
        glDeleteShader(vp->shader);
        check();
        vp->shader = 0;
        
        // TODO Free vertexProgram.
        
        return OUT_OF_MEMORY;
    }
    
    glGenVertexArrays(1, &vp->vao);
    check();
    if (vp->vao == 0)
    {
        glDeleteBuffers(static_cast<GLsizei>(vp->stream_vbos.size()), &vp->stream_vbos[0]);
        check();
        vp->stream_vbos.fill(0);
        
        glDeleteShader(vp->shader);
        check();
        vp->shader = 0;
        
        // TODO Free vertexProgram.
        
        return OUT_OF_MEMORY;
    }
    
    glBindVertexArray(vp->vao);
    check();
    
    for (int attribute_index = 0; attribute_index < attributeCount; ++attribute_index)
    {
        const SceGxmVertexAttribute *const attribute = &attributes[attribute_index];
        assert(attribute->streamIndex >= 0);
        assert(attribute->streamIndex < stack->streamCount);
        assert(attribute->streamIndex < vp->stream_vbos.size());
        
        const SceGxmVertexStream *const stream = &streams[attribute->streamIndex];
        
        glBindBuffer(GL_ARRAY_BUFFER, vp->stream_vbos[attribute->streamIndex]);
        check();
        
        const GLenum type = attribute_format_to_gl_type(attribute->format);
        const GLboolean normalised = attribute_format_normalised(attribute->format) ? GL_TRUE : GL_FALSE;
        const GLvoid *const pointer = reinterpret_cast<const GLvoid *>(attribute->offset);
        glVertexAttribPointer(attribute->regIndex, attribute->componentCount, type, normalised, stream->stride, pointer);
        check();
        
        glEnableVertexAttribArray(attribute->regIndex);
        check();
    }
    
    glBindVertexArray(0);
    check();
    
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    check();
    
    shaderPatcher->vertex_shaders[programId->program] = vp->shader;
    
    return SCE_OK;
}

IMP_SIG(sceGxmShaderPatcherDestroy)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmShaderPatcher *const shaderPatcher = Ptr<SceGxmShaderPatcher>(r0).get(&emu->mem);
    assert(shaderPatcher != nullptr);
    
    return SCE_OK;
}

IMP_SIG(sceGxmShaderPatcherRegisterProgram)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmShaderPatcher *const shaderPatcher = Ptr<SceGxmShaderPatcher>(r0).get(&emu->mem);
    const Ptr<const SceGxmProgram> programHeader(r1);
    SceGxmShaderPatcherId *const programId = Ptr<SceGxmShaderPatcherId>(r2).get(&emu->mem);
    assert(shaderPatcher != nullptr);
    assert(programHeader);
    assert(programId != nullptr);
    
    *programId = alloc<SceGxmRegisteredProgram>(&emu->mem, __FUNCTION__);
    assert(*programId);
    if (!*programId)
    {
        return OUT_OF_MEMORY;
    }
    
    SceGxmRegisteredProgram *const rp = programId->get(&emu->mem);
    rp->program = programHeader;
    
    return SCE_OK;
}

IMP_SIG(sceGxmShaderPatcherReleaseFragmentProgram)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmShaderPatcher *const shaderPatcher = Ptr<SceGxmShaderPatcher>(r0).get(&emu->mem);
    SceGxmFragmentProgram *const fragmentProgram = Ptr<SceGxmFragmentProgram>(r1).get(&emu->mem);
    assert(shaderPatcher != nullptr);
    assert(fragmentProgram != nullptr);
    
    glDeleteProgram(fragmentProgram->program);
    check();
    fragmentProgram->program = 0;
    
    // TODO Free fragmentProgram.
    
    return SCE_OK;
}

IMP_SIG(sceGxmShaderPatcherReleaseVertexProgram)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmShaderPatcher *const shaderPatcher = Ptr<SceGxmShaderPatcher>(r0).get(&emu->mem);
    SceGxmVertexProgram *const vertexProgram = Ptr<SceGxmVertexProgram>(r1).get(&emu->mem);
    assert(shaderPatcher != nullptr);
    assert(vertexProgram != nullptr);
    
    glDeleteShader(vertexProgram->shader);
    check();
    vertexProgram->shader = 0;
    
    glDeleteVertexArrays(1, &vertexProgram->vao);
    check();
    vertexProgram->vao = 0;
    
    glDeleteBuffers(static_cast<GLsizei>(vertexProgram->stream_vbos.size()), &vertexProgram->stream_vbos[0]);
    check();
    vertexProgram->stream_vbos.fill(0);
    
    // TODO Free vertexProgram.
    
    return SCE_OK;
}

IMP_SIG(sceGxmShaderPatcherUnregisterProgram)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmShaderPatcher *const shaderPatcher = Ptr<SceGxmShaderPatcher>(r0).get(&emu->mem);
    SceGxmRegisteredProgram *const programId = SceGxmShaderPatcherId(r1).get(&emu->mem);
    assert(shaderPatcher != nullptr);
    assert(programId != nullptr);
    
    shaderPatcher->vertex_shaders.erase(programId->program);
    programId->program.reset();
    
    // TODO Free programId.
    
    return SCE_OK;
}

IMP_SIG(sceGxmSyncObjectCreate)
{
    Ptr<SceGxmSyncObject> *const syncObject = Ptr<Ptr<SceGxmSyncObject>>(r0).get(&emu->mem);
    assert(syncObject != nullptr);
    
    *syncObject = alloc<SceGxmSyncObject>(&emu->mem, __FUNCTION__);
    if (!*syncObject)
    {
        return OUT_OF_MEMORY;
    }
    
    return SCE_OK;
}

IMP_SIG(sceGxmSyncObjectDestroy)
{
    // https://psp2sdk.github.io/gxm_8h.html
    SceGxmSyncObject *const syncObject = Ptr<SceGxmSyncObject>(r0).get(&emu->mem);
    assert(syncObject != nullptr);
    
    // TODO Free sync object.
    
    return SCE_OK;
}

IMP_SIG(sceGxmTerminate)
{
    return SCE_OK;
}

IMP_SIG(sceGxmTextureGetData)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    SceGxmTexture *const texture = Ptr<SceGxmTexture>(r0).get(mem);
    assert(texture != nullptr);
    
    return texture->data.address();
}

IMP_SIG(sceGxmTextureGetFormat)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    const SceGxmTexture *const texture = Ptr<const SceGxmTexture>(r0).get(mem);
    assert(texture != nullptr);
    
    return texture->format;
}

IMP_SIG(sceGxmTextureGetHeight)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    const SceGxmTexture *const texture = Ptr<const SceGxmTexture>(r0).get(mem);
    assert(texture != nullptr);
    
    return texture->height;
}

IMP_SIG(sceGxmTextureGetWidth)
{
    // https://psp2sdk.github.io/gxm_8h.html
    const MemState *const mem = &emu->mem;
    const SceGxmTexture *const texture = Ptr<const SceGxmTexture>(r0).get(mem);
    assert(texture != nullptr);
    
    return texture->width;
}

IMP_SIG(sceGxmTextureInitLinear)
{
    // https://psp2sdk.github.io/gxm_8h.html
    struct Stack
    {
        uint32_t height;
        uint32_t mipCount;
    };
    
    MemState *const mem = &emu->mem;
    const Stack *const stack = sp.cast<const Stack>().get(mem);
    SceGxmTexture *const texture = Ptr<SceGxmTexture>(r0).get(mem);
    const Ptr<const void> data(r1);
    const SceGxmTextureFormat texFormat = static_cast<SceGxmTextureFormat>(r2);
    const uint32_t width = r3;
    assert(texture != nullptr);
    assert(data);
    assert(texFormat == SCE_GXM_TEXTURE_FORMAT_U8U8U8U8_ABGR);
    assert(width > 0);
    assert(stack->height > 0);
    assert(stack->mipCount == 0);
    
    texture->format = texFormat;
    texture->width = width;
    texture->height = stack->height;
    texture->data = data;
    
    return SCE_OK;
}

IMP_SIG(sceGxmUnmapFragmentUsseMemory)
{
    // https://psp2sdk.github.io/gxm_8h.html
    void *const base = Ptr<void>(r0).get(&emu->mem);
    assert(base != nullptr);
    
    return SCE_OK;
}

IMP_SIG(sceGxmUnmapMemory)
{
    // https://psp2sdk.github.io/gxm_8h.html
    void *const address = Ptr<void>(r0).get(&emu->mem);
    assert(address != nullptr);
    
    return SCE_OK;
}

IMP_SIG(sceGxmUnmapVertexUsseMemory)
{
    // https://psp2sdk.github.io/gxm_8h.html
    void *const base = Ptr<void>(r0).get(&emu->mem);
    assert(base != nullptr);
    
    return SCE_OK;
}
